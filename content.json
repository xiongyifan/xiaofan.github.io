{"meta":{"title":"熊一帆的博客","subtitle":"","description":"","author":"熊一帆","url":"https://xiongyifan.github.io","root":"/"},"pages":[{"title":"tags","date":"2021-11-14T10:09:05.000Z","updated":"2021-11-14T10:14:54.737Z","comments":false,"path":"tags/index.html","permalink":"https://xiongyifan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CTPBEE","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/CTPBEE","date":"2021-11-13T17:52:37.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/投资/量化投资/编程/QUANTAXIS/CTPBEE/","link":"","permalink":"https://xiongyifan.github.io/knowledge/%E6%8A%95%E8%B5%84/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84/%E7%BC%96%E7%A8%8B/QUANTAXIS/CTPBEE/","excerpt":"","text":"QACTPBeeBroker的作用通过QACTPBEE命令接入实时的tick行情，然后通过QAPUBSUB订阅就能获取到行情 1QACTPBEE --userid 133496 --password QCHL1234 下面的第1和第2步只是为了在docker中执行上面的命令，也可以本地安装QACTPBeeBroker后手动执行上面命令，订阅的步骤是一样的。 当用docker-compose的qactpbeebroker时，默认会执行QACTPBEE命令，如果又手动执行了QACTPBEE命令就会推送两组数据。如果想手动启动只能本地安装，注释掉docker-compose.yaml中的启动命令是没有用的，因为源码中有默认的账号密码。 QACTPBeeBroker接入实时行情的步骤1. 增加qactpbeebroker模块在docker-compose.yaml中添加qactpbeebroker模块 123456789101112131415161718qactpbeebroker: image: daocloud.io/quantaxis/qactpbeebroker:latest container_name: qactpbeebroker ports: - &quot;5000:5000&quot; networks: qanetwork_pro: ipv4_address: 172.19.3.7 # --userid TEXT # --password TEXT # --brokerid TEXT # --mdaddr TEXT # --tdaddr TEXT # --appid TEXT # --authcode TEXT command: [&#x27;/root/wait_for_it.sh&#x27;, &#x27;qaeventmq:15672&#x27;, &#x27;--&#x27; , &quot;QACTPBEE&quot;, &quot;--userid&quot;, &quot;133496&quot;, &quot;--password&quot;, &#x27;QCHL1234&#x27;] 如果想用自己的账户可以在command中修改userid和password。 2. 启动如果是新添加的qactpbeebroker，那么可以直接通过下面的命令启动。 1docker-compose up -d 如果之前已经跟其他模块一起启动的话，qactpbeebroker可能会启动失败，原因不明。解决办法，手动重新启动下就好了。 12docker ps # 没有qactpbeebroker的话，说明已经停止运行了docker-compose start qactpbeebroker # 没有的话，运行命令启动 3. 检查1docker logs --tail 1000 -f qactpbeebroker 如果日志显示连接成功，或者有在打印合约代码，说明接入成功了。 接入成功后，15672页面会增加名为CTPX的Exchange。但是由于Exchange失效后不会自动在15672页面消失，所以有CTPX不意味着连接成功，看日志更保险。 订阅tick行情订阅tick行情，大概每秒2条tick行情 1qaps_sub --exchange CTPX --model direct --routing_key rb2201 订阅成功后，命令行显示tick行情 并且名为CTPX的Exchange增加 CTPBEE的任务是连接实盘tick行情，分钟行情则需要使用QARealtimeCollector二次采样分发。 问题docker-compose up -d所有容器全部一起启动，qactpbeebroker会死掉，手动再启动就好了，不知道怎么回事 10:15~10:30 rb2201数据停了，是因为这15分钟不是交易时间 Githubhttps://github.com/ctpbee/ctpbeehttps://github.com/yutiansut/QACTPBeeBroker","categories":[],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]},{"title":"QARealtimeCollector","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/QARealtimeCollector","date":"2021-11-13T17:52:37.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/投资/量化投资/编程/QUANTAXIS/QARealtimeCollector/","link":"","permalink":"https://xiongyifan.github.io/knowledge/%E6%8A%95%E8%B5%84/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84/%E7%BC%96%E7%A8%8B/QUANTAXIS/QARealtimeCollector/","excerpt":"","text":"QARealtimeCollector的作用QARealtimeCollector的作用有两个： 对实时tick数据进行二次采样，包括股票和期货。由QARC_WEBSERVER命令提供。 股票实时tick行情接入。由QARC_Stock提供，通过pytdx接入股票tick行情。 123# 命令行启动服务QARC_WEBSERVER # 提供http服务，进行股票和期货的订阅和二次采样QARC_Stock # 提供股票的tick行情 QARealtimeCollector安装步骤增加QARealtimeCollector模块在docker-compose.yaml中添加qamarketcollector模块 12345678910111213141516qamarketcollector: image: daocloud.io/quantaxis/qarealtimecollector:latest container_name: qamarketcollector ports: - &quot;8011:8011&quot; depends_on: - mgdb - qaeventmq environment: - MONGODB=mgdb - EventMQ_IP=qaeventmq networks: qanetwork_pro: ipv4_address: 172.19.3.8 command: [&#x27;/root/QUANTAXIS_RealtimeCollector/docker/wait_for_it.sh&#x27;, &#x27;qaeventmq:5672&#x27;, &#x27;--&#x27; ,&#x27;/root/QUANTAXIS_RealtimeCollector/docker/start_collector.sh&#x27;] command中指定的start_collector.sh脚本会执行QARC_WEBSERVER和QARC_Stock命令 启动如果是新添加的qamarketcollector，那么可以直接通过下面的命令启动。 1docker-compose up -d 如果之前已经跟其他模块一起启动的话，qamarketcollector模块会正常启动。 订阅分钟行情订阅地址：POST http://10.211.55.38:8011?action=new_handler&amp;market_type=future_cn&amp;code=rb2201 订阅成功后CTPX里面会增加一个rb2201，Exchange会增加realtime_min_rb2201和bar_1min_rb2201，然后命令行订阅就可以看到数据 12qaps_sub --exchange realtime_min_rb2201 --model fanoutqaps_sub --exchange bar_1min_rb2201 --model fanout 上面是realtime_min_rb2201的数据，下面是bar_1min_rb2201的数据。 二次采样x分钟数据POST http://10.211.55.38:8011?action=new_resampler&amp;market_type=future_cn&amp;code=rb2201&amp;frequence=5min 订阅成功后Exchange会增加一个realtime_5min_rb2201 1qaps_sub --exchange realtime_5min_rb2201 --model fanout 订阅股票tick数据POST http://10.211.55.38:8011?action=new_handler&amp;market_type=stock_cn&amp;code=000001 订阅成功后通过名为stocktransaction的exchange获取数据 1qaps_sub --exchange stocktransaction --model fanout http请求合集123456789101112# 订阅股票POST http://10.211.55.40:8011?action=new_handler&amp;market_type=stock_cn&amp;code=000001# 订阅期货POST http://10.211.55.40:8011?action=new_handler&amp;market_type=future_cn&amp;code=rb2201# 股票采样POST http://10.211.55.40:8011?action=new_resampler&amp;market_type=stock_cn&amp;code=000001&amp;frequence=5min# 期货采样POST http://10.211.55.40:8011?action=new_resampler&amp;market_type=future_cn&amp;code=rb2201&amp;frequence=5min# 现在的订阅POST http://10.211.55.40:8011?action=get_current_handler# 现在的采样POST http://10.211.55.40:8011?action=get_current_resampler GithubQUANTAXIS_RealtimeCollector 问题realtime_5min_rb2201的数据有，但是tradetime是错的，”tradetime”: “wrong date 22:36:30”，什么都没动，第二天的数据就正常了 股票数据出不来，原因是因为数据是从pytdx过来的，docker里的pytdx有问题，安装QQ群里的就好了","categories":[],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]},{"title":"QATrader","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/QATrader","date":"2021-11-13T17:52:37.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/投资/量化投资/编程/QUANTAXIS/QATrader/","link":"","permalink":"https://xiongyifan.github.io/knowledge/%E6%8A%95%E8%B5%84/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84/%E7%BC%96%E7%A8%8B/QUANTAXIS/QATrader/","excerpt":"","text":"模拟盘启动模拟账户123456# 进入qatrader容器docker exec -it qatrader /bin/bash# 开启模拟盘账户# 当指定一个新的acc执行这个命令时，会创建一个acc，存在数据库中# 已经创建过的acc可以在81页面查看，但是必须开启qatrader才能交易qatrader --acc 101010 --pwd 101010 --broker QUANTAXIS 输出下图日志就说明启动成功 同时RabbitMQ中会增加3个Exchange Exchange QAORDER_ROUTER增加账户信息 启动问题qatrader报参数个数错误，原因是python版本错误，应该用python3.6或3.7 qatrader报socket is already closed，原因是因为电脑刚刚从睡眠状态唤醒，需要等一会儿或者重启 在81页面中查看模拟账户 向模拟账户下单首先下单前要明确一个概念，模拟盘下单就像是在同花顺的模拟账户中操作，所以下单数据都是跟实盘一样的，除了资金是虚拟。 12345678910111213141516171819from QAPUBSUB.producer import publisher_routingimport datetime# 向模拟盘下单使用的是publisher_routing，而不是publisherpub = publisher_routing(exchange=&#x27;QAORDER_ROUTER&#x27;)# 卖空pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: &#x27;101010&#x27;, # 账户名 &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: &#x27;rb2201&#x27;, &#x27;price&#x27;: 3816, &#x27;order_direction&#x27;: &#x27;SELL&#x27;, &#x27;order_offset&#x27;: &#x27;OPEN&#x27;, &#x27;volume&#x27;: 1, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;,&#125;), routing_key=&#x27;101010&#x27;) # 账户名 发单后就可以在模拟账户中查看 下单问题 合约不合法，表示code参数有问题，code参数不能是指数或连续或过期合约，例如螺纹指数合约RBL8，2020年1月的螺纹合约RB2001 查看持仓和委托等信息123456789101112import pymongoimport os# 连接数据库db = pymongo.MongoClient(os.getenv(&#x27;MONGODB&#x27;)).QAREALTIME# 查到账户simacc = db.account.find_one(&#123;&#x27;account_cookie&#x27;: &#x27;101010&#x27;&#125;)# 获取委托信息simacc[&#x27;orders&#x27;]# 获取成交信息simacc[&#x27;trades&#x27;]# 获取持仓simacc[&#x27;positions&#x27;] 取消委托12345pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;cancel_order&#x27;, &#x27;account_cookie&#x27;: &#x27;101010&#x27;, # 账户名 &#x27;order_id&#x27;: &#x27;QAOTG_jHEJZXWk&#x27;,&#125;), routing_key=&#x27;101010&#x27;) # 账户名 问题，event显示撤单成功，但是orders里面还是显示ALIVE，难道是因为在非交易时间发起的撤单？ 多账户下单 同一个signal，只需要修改account就可以实现多账户下单，并且可以同时向模拟盘和实盘下单 12345678910111213for acc in [&#x27;101010&#x27;, &#x27;202020&#x27;]: pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: acc, # 账户名 &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: &#x27;rb2201&#x27;, &#x27;price&#x27;: 3816, &#x27;order_direction&#x27;: &#x27;SELL&#x27;, &#x27;order_offset&#x27;: &#x27;OPEN&#x27;, &#x27;volume&#x27;: 1, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;, &#125;), routing_key=acc) # 账户名 Http请求下单 Http下单跟Python下单一样，实际都是向名为QAORDER_ROUTER的Exchange发送信息。 首先开启qatraderserver，提供Http服务 12# docker版本的qatrader默认会启动qatraderserver，所以可以不用再手动启动，配置启动qatraderserver的位置在docker-compose.yaml中qatraderserver # 再次启动，报端口占用 接口查看https://github.com/yutiansut/QATrader 实盘下单操作汇总卖空123456789101112pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: &#x27;101010&#x27;, # 账户名 &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: &#x27;rb2201&#x27;, &#x27;price&#x27;: 3816, &#x27;order_direction&#x27;: &#x27;SELL&#x27;, &#x27;order_offset&#x27;: &#x27;OPEN&#x27;, &#x27;volume&#x27;: 1, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;,&#125;), routing_key=&#x27;101010&#x27;) # 账户名 平今多123456789101112pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: &#x27;101010&#x27;, # 账户名 &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: &#x27;rb2201&#x27;, &#x27;price&#x27;: 3816, &#x27;order_direction&#x27;: &#x27;SELL&#x27;, &#x27;order_offset&#x27;: &#x27;CLOSETODAY&#x27;, &#x27;volume&#x27;: 1, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;,&#125;), routing_key=&#x27;101010&#x27;) # 账户名 取消委托12345pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;cancel_order&#x27;, &#x27;account_cookie&#x27;: &#x27;101010&#x27;, # 账户名 &#x27;order_id&#x27;: &#x27;QAOTG_jHEJZXWk&#x27;,&#125;), routing_key=&#x27;101010&#x27;) # 账户名 实盘账户数据库说明https://doc.shinnytech.com/tqsdk2/latest/reference/tqsdk2.objs.position.html 持仓说明simacc[‘positions’][‘SHFE_rb2201’] 123456789101112131415161718192021222324252627282930313233343536373839&#123;&#x27;user_id&#x27;: &#x27;marco07281&#x27;, # qatrader命令的--acc指定的用户名 &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;, # 交易所id &#x27;instrument_id&#x27;: &#x27;rb2201&#x27;, # 合约名称 &#x27;volume_long_today&#x27;: 1, # 今日下单的多单 &#x27;volume_long_his&#x27;: 0, # 历史持有的多单 &#x27;volume_long&#x27;: 1, # 总多单 = 今日 + 历史 &#x27;volume_long_frozen_today&#x27;: 0, &#x27;volume_long_frozen_his&#x27;: 0, &#x27;volume_long_frozen&#x27;: 0, &#x27;volume_short_today&#x27;: 0, &#x27;volume_short_his&#x27;: 0, &#x27;volume_short&#x27;: 0, &#x27;volume_short_frozen_today&#x27;: 0, &#x27;volume_short_frozen_his&#x27;: 0, &#x27;volume_short_frozen&#x27;: 0, &#x27;volume_long_yd&#x27;: 0, &#x27;volume_short_yd&#x27;: 0, &#x27;pos_long_his&#x27;: 0, &#x27;pos_long_today&#x27;: 1, # 跟volume_long_today一样？ &#x27;pos_short_his&#x27;: 0, &#x27;pos_short_today&#x27;: 0, &#x27;open_price_long&#x27;: 4249.0, # 多仓均价？ &#x27;open_price_short&#x27;: 0.0, &#x27;open_cost_long&#x27;: 42490.0, # 持有的多单总成本？ &#x27;open_cost_short&#x27;: 0.0, &#x27;position_price_long&#x27;: 4249.0, # 跟open_price_long有什么区别？ &#x27;position_price_short&#x27;: 0.0, &#x27;position_cost_long&#x27;: 42490.0, # 跟open_cost_long有什么区别？ &#x27;position_cost_short&#x27;: 0.0, &#x27;last_price&#x27;: 4262.0, # 实时的价格，会跟着行情一直变 &#x27;float_profit_long&#x27;: 130.0, # 实时的多单浮盈？ &#x27;float_profit_short&#x27;: 0.0, # 实时的空单浮盈？ &#x27;float_profit&#x27;: 130.0, # 实时浮盈 &#x27;position_profit_long&#x27;: 130.0, # 跟float_profit_long有什么区别 &#x27;position_profit_short&#x27;: 0.0, &#x27;position_profit&#x27;: 130.0, # 跟float_profit有什么区别 &#x27;margin_long&#x27;: 3308.8, # 多单保证金 &#x27;margin_short&#x27;: 0.0, # 空单保证金 &#x27;margin&#x27;: 3308.8&#125; # 总保证金","categories":[],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS脚本安装","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/QUANTAXIS脚本安装","date":"2021-11-13T17:52:37.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/投资/量化投资/编程/QUANTAXIS/QUANTAXIS脚本安装/","link":"","permalink":"https://xiongyifan.github.io/knowledge/%E6%8A%95%E8%B5%84/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84/%E7%BC%96%E7%A8%8B/QUANTAXIS/QUANTAXIS%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85/","excerpt":"","text":"Docker安装Docker安装 QUANTAXIS安装通过wget下载脚本安装之前，需要先准备好QQ群中的QA和pytdx，并与脚本放在同一个目录下。 1curl -sSL https://gitee.com/xiongyifan/quantaxis-study/raw/master/bash/install_qa.sh | sh QUANTAXIS初始化以下内容复制自QQ群公告第一次部署docker版QA必须的初始化操作步骤：一、在浏览器输入docker宿主机”ip地址:8888”；二、进入jupyterlab登录界面后输入口令”quantaxis”;三、进入jupyterlab启动页，点击Terminal进入终端；四、在终端界面输入”/bin/bash”,进入bash状态；五、bash状态输入”quantaxis”,进入数据库操作状态；六：依次输入完成数据库初始化“save stock_list”，”save single_index_day 000300”输入exit退出终端，在docker管理界面重启qaweb容器，最后浏览器输入docker宿主机”ip地址:81”，弹出的登录界面把登录地址端口改为docker宿主机”ip地址:8010”,就可以进入QA前端界面","categories":[],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]},{"title":"Ubuntu远程免密码登录设置","slug":"knowledge/编程/操作系统/LInux/Ubuntu/Ubuntu远程免密码登录设置","date":"2021-11-13T17:52:37.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/编程/操作系统/LInux/Ubuntu/Ubuntu远程免密码登录设置/","link":"","permalink":"https://xiongyifan.github.io/knowledge/%E7%BC%96%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/LInux/Ubuntu/Ubuntu%E8%BF%9C%E7%A8%8B%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"原文地址https://zhuanlan.zhihu.com/p/35878555 Ubuntu 远程免密码登录设置我们正常使用 ssh 远程登录服务器进行操作，需要输入用户名、服务器ip以及密码，当我们需要同时管理多个服务器的时候，每次都需要重复输入这些东西会显得特别麻烦和浪费时间，因此我们可以通过配置密钥来实现Ubuntu免密码登录。 实现这一目标五部，分别为： 本地客户端生成密钥对 上传密钥到服务器端 服务器端将密钥添加到 authorized_keys 本地客户端配置 ssh，添加服务器别名 测试 如果客户端是使用 MacOS 或者 Linux 系统，可以直接在终端使用以下操作即可，如果 Window 系统，建议先安装 Git-Bash，Git-bash 自带 ssh 工具，在 Git-Bash 下，操作也和 Linux 或者 MacOS 系统一样。 本地客户端生成密钥对在生成密钥对之前，我们可以先查看一下我们是否已经生成过密钥对，可以通过以下命令： 1ls -la ~/.ssh 如果输出有 id_rsa 和 id_rsa.pub，那么就证明之前曾经生成过密钥对，其中 id_rsa 是私钥，id_rsa.pub 是公钥，我们可以直接使用。如果没有看到这两个文件，那么请回忆是否自己命名的密钥对，如果没有或者已经忘记是否曾经生成过，那么久可以重新创建一个。方法如下： 1ssh-keygen -t rsa -b 2048 执行命令后，会提示密钥存储位置，以及询问是否需要设置密码，一般我们可以一路按 Enter 确认即可完成密钥生成。 完成后我们再次查看 ~/.ssh 文件夹下是否由我们新创建的密钥即可。 上传密钥的服务器端接下来，我们将我们创建好的公钥上传到服务器上，我们将会使用到 scp 命令。 123scp ~/.ssh/id_rsa.pub 用户名@服务器ip:~# 方便直接填用户名和ipscp ~/.ssh/id_rsa.pub @:~ 这里需要注意的是，我们需要上传的是公钥，其文件名为 id_rsa.pub，私钥是需要我们保密的，这里不要上传错。 服务器端将密钥添加到 authorized_keys接下来，我们需要登录我们的服务器，然后将我们刚上传的公钥添加到 authorized_keys中。在添加之前，我们需要先做一下准备，具体如下： 检查是否存在 .ssh 文件 如果不存在需要自行创建如果是刚安装的系统，以我的 Ubuntu 16.04.4 为例，默认的 ssh 是没有自动创建 .ssh 文件夹的，这需要我们自己创建。不同版本的系统或者以不同途径安装的 ssh 可能情况会有所不一样，请根据实际情况处理。 123456# 查看是否存来 .ssh 文件夹ls -la ~# 如果不存在，创建 .ssh 文件夹mkdir .ssh# 将公钥添加到 authorized_keys 文件中cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 以上即完成操作，在 Ubuntu 16.04.4 的系统默认配置中，以上操作完成即可。然而，在一些不同版本的系统中，可能还需要配置以下 ssh 的配置，具体如下： 备份 /etc/ssh/sshd_config 编辑 /etc/ssh/sshd_config ，将 PubkeyAuthentication no 修改为 PubkeyAuthentication yes 本地客户端配置 ssh，添加服务器别名完成上面的配置后，我们可以尝试在本地中尝试使用密钥登录看是否成功： 1ssh -i ~/.ssh/id_rsa &lt;YOUR SERVER NAME&gt;@&lt;YOUR SERVER IP ADDRESS&gt; 如果配置正确就可以正常免密码登录。 为了解决需要管理多台服务器，不希望记住太多不同的用户名和地址的问题，我们还可以为设置别名登录，具体操作如下： 在本地 .ssh/ 文件夹下创建 config 向 config 中添加别名信息 123456# ~/.ssh/config 配置格式Host &lt;YourServerAlias&gt; HostName &lt;YourServerIPAddress&gt; Port &lt;YourServerSSHPort&gt; User &lt;YourServerUserName&gt; IdentityFile ~/.ssh/id_rsa 测试完成所有配置后，我们可以测试一下配置是否正确： 1ssh &lt;Host Alias&gt; 如果能正常免密码登录，说明配置成功，我们以后便可以通过这样直接输入服务器别名的方式快速登录服务器了。","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://xiongyifan.github.io/tags/Ubuntu/"}]},{"title":"Ubuntu配置SSH服务端支持远程登录","slug":"knowledge/编程/操作系统/LInux/Ubuntu/Ubuntu配置SSH服务端支持远程登录","date":"2021-11-13T17:52:37.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/编程/操作系统/LInux/Ubuntu/Ubuntu配置SSH服务端支持远程登录/","link":"","permalink":"https://xiongyifan.github.io/knowledge/%E7%BC%96%E7%A8%8B/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/LInux/Ubuntu/Ubuntu%E9%85%8D%E7%BD%AESSH%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%94%AF%E6%8C%81%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/","excerpt":"","text":"原文地址https://juejin.cn/post/6844904048739500046 目标用另外一台电脑ssh访问Ubuntu系统的电脑 硬件及软件版本 被访问电脑 电脑：联想笔记本G470 系统：Ubuntu 16.04 客户端电脑 电脑：MBP 系统：10.15.2 准备SSH SSH 为Secure Shell的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、DigitalUNIX、Irix，以及其他平台，都可运行SSH。– 搜狗百科：SSH 目标分析现在我们知道SSH其实最早是一个安全协议，这个协议就是为远程登录会话而生。因为这个协议，衍生的的SSH程序是我们要安装的软件。要利用SSH连接两台机器，可想可知一个要作为客户端访问，另外一台要作为服务端提供被访问的服务。我们也知道很多Linux、OSX等类Unix系统都已自带了SSH的客户端，Windows也有不少类似PuTTY这样优秀的软件。So，我们接下来要做的其实是如何安装并开启SSH Server。 步骤① 确定Ubuntu是否安装SSH服务12systemctl status ssh复制代码 比如，这台新系统的机器执行结果如下： 我们注意到两个内容，第一行 加载结果是 未发现，原因没有这个文件或目录，第二行 服务状态是不活跃的，死亡的。从这些词我们能猜到其实这个服务压根就没安装。同理，假如你看到的状态是类似红色的stopped字样，是终止态的，可以用命令 sudo systemctl start ssh 尝试启动，执行结果也可以参考第③步。 ② 安装SSH Server12sudo apt install openssh-server复制代码 执行过程如下 ③ 确定Ubuntu SSH服务状态12systemctl status ssh复制代码 执行结果如下 现在能看到：第一行加载状态，已加载ssh.service文件；第二行是否活动，正在运行；并且留意到一个守护进程sshd；再往下看到监听的端口是22。 至此，我们的SSH服务端已经安装启动OK。 ④ 确定Ubuntu机器的IP我们在局域网测试，那就是查看现在这台局域网IP，可以点击网络设置查看，亦或命令行 ifcofnig 如下图的一个参考，找到你活跃的网卡。比如这台机器的是 192.168.0.145。 ⑤ 确定是否可访问Ubuntu12ping 192.168.0.145复制代码 如果能ping通，这说明网络是通的，那么可以尝试第⑦步。如果有类似 ssh: connect to host 192.168.0.145 port 22: Connection refused 这样的问题是说明端口不能访问，要检查下防火墙。 ⑥ 若不能访问，检查Ubuntu防火墙123456789# 检查防火墙sudo ufw status verbose# 开启防火墙sudo ufw enable# 开放端口sudo ufw allow 22复制代码 如下命令，可以设置开放来自某IP访问某端口的权限 12sudo ufw allow from your_ip to any port 22复制代码 ⑦ 使用账号密码登录Ubuntu现在，使用另外一台电脑尝试登录 Ubuntu 12ssh baiyutang@192.168.0.145 -p 22复制代码 对于第一次登陆的会提示主机不被认可，加密签名的指 输入 yes 确认，继续需要验证 Ubuntu 当前用户 baiyutang 的登录密码，输入确认即可登录成功。 延伸 openssh-server是什么？ Ubuntu Wiki OpenSSH Server About OpenSSH SSH服务端开放的端口可以更改吗？ 可以，在文件 /etc/ssh/sshd_config 里可以配置 SSH Server 开放的端口，修改后记得 sudo systemctl restart sshd 重启下生效。修改位置如下图第 5 行所示： ufw及基本的管理操作 Ubuntu防火墙设置可以单独抽出来讲，或者可以先看参考资料第四条。 如何使用公钥免密登录？ SSH加密传输的过程原理？ 加密签名指纹是什么？ 这个等下篇专门来做记录，三个问题可以放在一起。 如何配置跳板机？ 这个也后续单独做。 安全问题及中间人攻击 在参考第一条有讲到这个问题。 内网穿透是什么？ 后续了解及研究，因为有段时间也在寻找和远程控制相关软件，可以作为研究课题。 参考 ssh 基本原理和免密码登录 五条强化 SSH 安全的建议 牢记25个最佳的SSH命令 在Ubuntu中用UFW配置防火墙 在 Mac 上使用防火墙来防止非法连接","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://xiongyifan.github.io/tags/Ubuntu/"}]},{"title":"QUANTAXIS从安装到实盘","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/安装到实盘/QUANTAXIS从安装到实盘","date":"2021-11-13T17:52:37.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/投资/量化投资/编程/QUANTAXIS/安装到实盘/QUANTAXIS从安装到实盘/","link":"","permalink":"https://xiongyifan.github.io/knowledge/%E6%8A%95%E8%B5%84/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84/%E7%BC%96%E7%A8%8B/QUANTAXIS/%E5%AE%89%E8%A3%85%E5%88%B0%E5%AE%9E%E7%9B%98/QUANTAXIS%E4%BB%8E%E5%AE%89%E8%A3%85%E5%88%B0%E5%AE%9E%E7%9B%98/","excerpt":"","text":"配置ssh免密连接（可选）Ubuntu配置SSH服务端支持远程登录Ubuntu远程免密码登录设置 QUANTAXIS脚本安装QUANTAXIS脚本安装 QUANTAXIS本地数据本地撮合QUANTAXIS本地数据本地撮合 QUANTAXIS实时数据本地撮合QUANTAXIS实时数据本地撮合 QUANTAXIS实时数据模拟撮合QUANTAXIS实时数据模拟撮合 QUANTAXIS实时数据实盘交易待完成","categories":[],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]},{"title":"Docker安装","slug":"knowledge/编程/容器/Docker/Docker安装","date":"2021-11-13T17:52:37.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/编程/容器/Docker/Docker安装/","link":"","permalink":"https://xiongyifan.github.io/knowledge/%E7%BC%96%E7%A8%8B/%E5%AE%B9%E5%99%A8/Docker/Docker%E5%AE%89%E8%A3%85/","excerpt":"","text":"Ubuntu安装脚本wget下载脚本安装，脚本中包括安装docker，开启非root用户执行docker命令，修改docker源（腾讯）。 1curl -sSL https://gitee.com/xiongyifan/quantaxis-study/raw/master/bash/install_docker.sh | sh Window安装系统选择Win10专业版或者企业版：这两个版本有hyper-v功能，可以安装docker-ceWin10家庭版或ghost：家庭版没有hyper-v功能，ghost版本可能阉割了hyper-v，所以装不了docker-ceWin7：只能安装docker toolbox，本质是虚拟机，依赖多，而且从github上下载很慢。 安装过程中的问题安装过程中要选择linux container，而不是window container。否则会遇到docker-compose版本过旧的问题。","categories":[{"name":"Docker","slug":"Docker","permalink":"https://xiongyifan.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xiongyifan.github.io/tags/Docker/"}]},{"title":"QUANTAXIS实时数据本地撮合","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/安装到实盘/QUANTAXIS实时数据本地撮合","date":"2021-11-13T17:52:37.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/投资/量化投资/编程/QUANTAXIS/安装到实盘/QUANTAXIS实时数据本地撮合/","link":"","permalink":"https://xiongyifan.github.io/knowledge/%E6%8A%95%E8%B5%84/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84/%E7%BC%96%E7%A8%8B/QUANTAXIS/%E5%AE%89%E8%A3%85%E5%88%B0%E5%AE%9E%E7%9B%98/QUANTAXIS%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E6%9C%AC%E5%9C%B0%E6%92%AE%E5%90%88/","excerpt":"","text":"实时tick数据接入CTPBEE 实时tick数据接入后，就可以进行二次采样 二次采样数据QARealtimeCollector 订阅rb2201成功后，下面通过bar_1min_rb2201做策略 创建用户账户的account_cookie改成了test_realtime_simpledeal，测试实时数据simpledeal撮合。 1acc = port.new_account(&#x27;test_realtime_simpledeal&#x27;, 100000, QA.MARKET_TYPE.FUTURE_CN) 策略set_index的date，改成了datetime，之前本地数据用的日线的date，现在是1分钟实时数据用的是datetime 1market_data_df = pd.DataFrame(market_data_list).set_index(&#x27;datetime&#x27;, drop=False) trade_time改成datetime，之前本地数据用的日线的date+’ 00:00:00’，现在1分钟实时数据直接用datetime 1trade_time = bar[&#x27;datetime&#x27;] 数据是实时推送的，不能在所有代码执行完毕后查看结果。所以在策略的最后保存了acc，可随时通过代码或数据库查看交易情况。 1acc.save() 订阅数据exchange改成了bar_1min_rb2201，之前的exchange是自己命名的，现在订阅的是实时1分钟的螺纹钢 1sub = subscriber(exchange=&#x27;bar_1min_rb2201&#x27;) 数据获取并推送数据这块代码不需要了。数据是CTPX主动推送的，所以只需要在上面订阅好需要数据就行。 查看和保存结果这两块也不需要了，数据是慢慢推过来的，想看阶段结果就用acc查看即可。 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import QUANTAXIS as QAfrom QAPUBSUB.consumer import subscriberfrom QAPUBSUB.producer import publisherimport threading, jsonimport pandas as pd# 1. 账户准备user = QA.QA_User(username=&#x27;admin&#x27;, password=&#x27;admin&#x27;)port = user.new_portfolio(&#x27;x1&#x27;)acc = port.new_account(&#x27;test_realtime_simpledeal&#x27;, 100000, QA.MARKET_TYPE.FUTURE_CN)# 2. 发单操作方法def sendorder(code, trade_price, trade_towards, trade_time): acc.receive_simpledeal( code=code, trade_price=trade_price, trade_amount=trade_amount, trade_towards=trade_towards, trade_time=trade_time)# 3. 策略market_data_list = []def on_data(a, b, c, data): # 数据准备 bar = json.loads(data) market_data_list.append(bar) market_data_df = pd.DataFrame(market_data_list).set_index(&#x27;datetime&#x27;, drop=False) # 计算指标 ind = QA.QA_indicator_MA(market_data_df, 2, 4) print(ind) # 策略逻辑 MA2 = ind.iloc[-1][&#x27;MA2&#x27;] MA4 = ind.iloc[-1][&#x27;MA4&#x27;] code = bar[&#x27;code&#x27;] trade_price = bar[&#x27;close&#x27;] trade_amount = 1 trade_time = bar[&#x27;datetime&#x27;] code_hold_available = acc.hold_available.get(code, 0) if MA2 &gt; MA4: if code_hold_available == 0: print(&#x27;买多&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.BUY_OPEN, trade_time) elif code_hold_available &gt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平空&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.BUY_CLOSE, trade_time) elif MA4 &gt; MA2: if code_hold_available == 0: print(&#x27;卖空&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.SELL_OPEN, trade_time) elif code_hold_available &lt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平多&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.SELL_CLOSE, trade_time) else: print(&#x27;不操作&#x27;) # 保存结果 acc.save() # 4. 订阅数据sub = subscriber(exchange=&#x27;bar_1min_rb2201&#x27;)sub.callback=on_datathreading.Thread(target=sub.start).start()","categories":[],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS实时数据模拟撮合","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/安装到实盘/QUANTAXIS实时数据模拟撮合","date":"2021-11-13T17:52:37.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/投资/量化投资/编程/QUANTAXIS/安装到实盘/QUANTAXIS实时数据模拟撮合/","link":"","permalink":"https://xiongyifan.github.io/knowledge/%E6%8A%95%E8%B5%84/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84/%E7%BC%96%E7%A8%8B/QUANTAXIS/%E5%AE%89%E8%A3%85%E5%88%B0%E5%AE%9E%E7%9B%98/QUANTAXIS%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E6%A8%A1%E6%8B%9F%E6%92%AE%E5%90%88/","excerpt":"","text":"整个流程与QUANTAXIS实时数据本地撮合有两点不同： 模拟撮合通过qatrader模块连接模拟盘账户完成订单。 账户查询操作通过数据库完成，而不是QAAccount 模拟账户接入QATrader 接入成功后，通过pub发单即可。 账户准备账户查询操作通过数据库完成，而不是QAAccountaccount_cookie是qatader命令指定的–accqatader执行成功后就可以在数据库查询到账户信息。 123456# 1. 账户准备account_cookie = &#x27;101010&#x27;db = pymongo.MongoClient(os.getenv(&#x27;MONGODB&#x27;)).QAREALTIMEdef find_acc(): return db.account.find_one(&#123;&#x27;account_cookie&#x27;: account_cookie&#125;)simacc = find_acc() 发单操作方法模拟账户通过pub到名为QAORDER_ROUTER的Exchange完成发单，而不是调用simple_deal。 为简化流程sendorder发单价格要高些，不然会出现多次买多等情况。 123456789101112131415pub = publisher_routing(exchange=&#x27;QAORDER_ROUTER&#x27;)def sendorder(code, price, order_direction, order_offset, volume): routing_key = account_cookie pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: account_cookie, &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: code, &#x27;price&#x27;: price, &#x27;order_direction&#x27;: order_direction, &#x27;order_offset&#x27;: order_offset, &#x27;volume&#x27;: volume, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;, &#125;), routing_key=routing_key) 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import QUANTAXIS as QAfrom QAPUBSUB.consumer import subscriberfrom QAPUBSUB.producer import publisher, publisher_routingimport threading, json, pymongo, os, datetimeimport pandas as pd# 1. 账户准备account_cookie = &#x27;marco07281&#x27;db = pymongo.MongoClient(os.getenv(&#x27;MONGODB&#x27;)).QAREALTIMEdef find_acc(): return db.account.find_one(&#123;&#x27;account_cookie&#x27;: account_cookie&#125;)simacc = find_acc()# 2. 发单操作方法BUY = &#x27;BUY&#x27;SELL = &#x27;SELL&#x27;OPEN = &#x27;OPEN&#x27;CLOSETODAY = &#x27;CLOSETODAY&#x27;pub = publisher_routing(exchange=&#x27;QAORDER_ROUTER&#x27;)def sendorder(code, price, order_direction, order_offset, volume): routing_key = account_cookie pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: account_cookie, &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: code, &#x27;price&#x27;: price, &#x27;order_direction&#x27;: order_direction, &#x27;order_offset&#x27;: order_offset, &#x27;volume&#x27;: volume, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;, &#125;), routing_key=routing_key)# 3. 策略market_data_list = []def on_data(a, b, c, data): # 数据准备 bar = json.loads(data) market_data_list.append(bar) market_data_df = pd.DataFrame(market_data_list).set_index(&#x27;datetime&#x27;, drop=False) # 计算指标 ind = QA.QA_indicator_MA(market_data_df, 2, 4) print(ind) # 策略逻辑 MA2 = ind.iloc[-1][&#x27;MA2&#x27;] MA4 = ind.iloc[-1][&#x27;MA4&#x27;] code = bar[&#x27;code&#x27;].lower() trade_price = bar[&#x27;close&#x27;] trade_amount = 1 trade_time = bar[&#x27;datetime&#x27;] simacc = find_acc() positions = simacc[&#x27;positions&#x27;] code_key = &#x27;SHFE_&#x27; + &#x27;rb2201&#x27; volume_long = positions[code_key][&#x27;volume_long&#x27;] if code_key in positions else 0 volume_short = positions[code_key][&#x27;volume_short&#x27;] if code_key in positions else 0 print(MA2, MA4, code, trade_price, trade_time, volume_long, volume_short) if MA2 &gt; MA4: # 先平空，否则会先执行买多，就会不会平空了 if volume_short &gt; 0: print(&#x27;平空&#x27;) sendorder(code, trade_price + 5, BUY, CLOSETODAY, trade_amount) if volume_long == 0: print(&#x27;买多&#x27;) sendorder(code, trade_price + 5, BUY, OPEN, trade_amount) elif volume_long &gt; 0: print(&#x27;持有&#x27;) elif MA4 &gt; MA2: if volume_long &gt; 0: print(&#x27;平多&#x27;) sendorder(code, trade_price - 5, SELL, CLOSETODAY, trade_amount) if volume_short == 0: print(&#x27;卖空&#x27;) sendorder(code, trade_price - 5, SELL, OPEN, trade_amount) elif volume_short &gt; 0: print(&#x27;持有&#x27;) else: print(&#x27;不操作&#x27;)# 3. 订阅数据sub = subscriber(exchange=&#x27;bar_1min_rb2201&#x27;)sub.callback=on_datathreading.Thread(target=sub.start).start()","categories":[],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS本地数据本地撮合","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/安装到实盘/QUANTAXIS本地数据本地撮合","date":"2021-11-13T17:52:37.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/投资/量化投资/编程/QUANTAXIS/安装到实盘/QUANTAXIS本地数据本地撮合/","link":"","permalink":"https://xiongyifan.github.io/knowledge/%E6%8A%95%E8%B5%84/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84/%E7%BC%96%E7%A8%8B/QUANTAXIS/%E5%AE%89%E8%A3%85%E5%88%B0%E5%AE%9E%E7%9B%98/QUANTAXIS%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E6%9C%AC%E5%9C%B0%E6%92%AE%E5%90%88/","excerpt":"","text":"QUANTAXIS本地数据本地撮合完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import QUANTAXIS as QAfrom QAPUBSUB.consumer import subscriberfrom QAPUBSUB.producer import publisherimport threading, jsonimport pandas as pd# 1. 账户准备user = QA.QA_User(username=&#x27;admin&#x27;, password=&#x27;admin&#x27;)port = user.new_portfolio(&#x27;x1&#x27;)acc = port.new_account(&#x27;test_local_simpledeal&#x27;, 100000, QA.MARKET_TYPE.FUTURE_CN)# 2. 发单操作方法def sendorder(code, trade_price, trade_towards, trade_time): acc.receive_simpledeal( code=code, trade_price=trade_price, trade_amount=trade_amount, trade_towards=trade_towards, trade_time=trade_time)# 3. 策略market_data_list = []def on_data(a, b, c, data): # 数据准备 bar = json.loads(data) market_data_list.append(bar) market_data_df = pd.DataFrame(market_data_list).set_index(&#x27;date&#x27;, drop=False) # 计算指标 ind = QA.QA_indicator_MA(market_data_df, 2, 4) print(ind) # 策略逻辑 MA2 = ind.iloc[-1][&#x27;MA2&#x27;] MA4 = ind.iloc[-1][&#x27;MA4&#x27;] code = bar[&#x27;code&#x27;] trade_price = bar[&#x27;close&#x27;] trade_amount = 1 trade_time = bar[&#x27;date&#x27;] + &#x27; 00:00:00&#x27; code_hold_available = acc.hold_available.get(code, 0) if MA2 &gt; MA4: if code_hold_available == 0: print(&#x27;买多&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.BUY_OPEN, trade_time) elif code_hold_available &gt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平空&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.BUY_CLOSE, trade_time) elif MA4 &gt; MA2: if code_hold_available == 0: print(&#x27;卖空&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.SELL_OPEN, trade_time) elif code_hold_available &lt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平多&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.SELL_CLOSE, trade_time) else: print(&#x27;不操作&#x27;) # 4. 订阅数据sub = subscriber(exchange=&#x27;x1&#x27;)sub.callback=on_datathreading.Thread(target=sub.start).start()# 5. 数据获取并推送数据# 获取df = QA.QA_fetch_get_future_day(&#x27;tdx&#x27;, &#x27;RBL8&#x27;, &#x27;2019-08-01&#x27;, &#x27;2019-08-30&#x27;)# 推送pub = publisher(exchange=&#x27;x1&#x27;)for idx, item in df.iterrows(): pub.pub(item.to_json())# 6. 查看结果risk = QA.QA_Risk(acc)performance = QA.QA_Performance(acc)acc.history_tablerisk.plot_assets_curve()performance.pnl# 7. 保存结果acc.save()risk.save() 问题 需要存数据，因为qa_risk会调用QA_fetch_stock_day_adv，这个方法会从数据读数据，读不到数据后面的指标不能计算（已解决） receive_simpledeal的trade_time，要用%Y-%m-%d %H:%M:%S格式，因为history_min会用到这个格式，格式不对会计算不出history_min，导致后面指标不能计算。（已解决） 在存了数据，trade_time写对之后，performance.pnl等等都能计算出来了，但是81界面的绩效分析就是出不来，不知道为什么（未解决） acc = port.new_account(‘test1’, 100000, QA.MARKET_TYPE.FUTURE_CN, auto_reload=False)，跑第一次的时候会把acc存在数据库，第二次再跑的时候，创建有问题，market_type会变成stock_cn，因为走的另外一个创建逻辑，具体看QAPortfolio的第385行。但是如果auto_reload是true的话就不会有问题，因为会从数据库读取覆盖掉创建时赋值的参数。","categories":[],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]}],"categories":[{"name":"Docker","slug":"Docker","permalink":"https://xiongyifan.github.io/categories/Docker/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://xiongyifan.github.io/tags/Ubuntu/"},{"name":"Docker","slug":"Docker","permalink":"https://xiongyifan.github.io/tags/Docker/"}]}
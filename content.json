{"meta":{"title":"熊一帆的博客","subtitle":"","description":"","author":"熊一帆","url":"https://xiongyifan.github.io","root":"/"},"pages":[{"title":"","date":"2021-11-17T12:36:53.532Z","updated":"2021-11-17T12:36:53.532Z","comments":true,"path":"baidu_verify_code-vIzhiqpRgd.html","permalink":"https://xiongyifan.github.io/baidu_verify_code-vIzhiqpRgd.html","excerpt":"","text":"a6681937874929680fc6a073f6fe9e16"},{"title":"分类","date":"2021-11-16T15:18:35.000Z","updated":"2021-11-16T15:18:59.952Z","comments":false,"path":"categories/index.html","permalink":"https://xiongyifan.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-11-17T12:41:36.057Z","updated":"2021-11-17T12:41:36.057Z","comments":true,"path":"google0149e156ffc0b0f7.html","permalink":"https://xiongyifan.github.io/google0149e156ffc0b0f7.html","excerpt":"","text":"google-site-verification: google0149e156ffc0b0f7.html"},{"title":"tags","date":"2021-11-14T10:09:05.000Z","updated":"2021-11-14T10:14:54.737Z","comments":false,"path":"tags/index.html","permalink":"https://xiongyifan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"QUANTAXIS-QAPUBSUB消息订阅组件","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/QUANTAXIS-QAPUBSUB消息订阅组件","date":"2021-11-16T10:16:07.000Z","updated":"2021-11-16T13:46:54.000Z","comments":true,"path":"knowledge/9415a00b301cc96e/","link":"","permalink":"https://xiongyifan.github.io/knowledge/9415a00b301cc96e/","excerpt":"QAPUBSUB的作用 原始模式: 通过for循环遍历数据订阅模式: 通过eventmq发布订阅数据","text":"QAPUBSUB的作用 原始模式: 通过for循环遍历数据订阅模式: 通过eventmq发布订阅数据 原始模式12345import QUANTAXIS as QAdf = QA.QA_fetch_get_future_day(&#x27;tdx&#x27;, &#x27;RBL8&#x27;, &#x27;2019-09-01&#x27;, &#x27;2019-09-30&#x27;)for idx, data in df.iterrows(): print(&#x27;on_data: &#x27;, data) # 策略代码。。。 优点： 逻辑清晰 单个策略执行速度快 缺点在多个策略同时运行时暴露： API访问次数限制 同时访问数据库压力大 订阅模式 以中间的eventmq为媒介，生产者发布数据，消费者订阅接收数据。生产者发布一次，多个消费者接收数据，执行各自的逻辑。消费者加工数据后可以发布数据，供其他消费者使用，例如：图中消费者tick2Bar把tick数据变成bar数据后发布，策略订阅了bar数据，bar数据一来策略就运行起来了。 优点在多个策略同时运行时尤为明显： 多策略，数据持久化，发单等等写起来都很方便，只要订阅就好 缺点在多个策略同时运行时暴露： 逻辑上需要理解下 单策略执行速度不如for循环，毕竟有eventmq的开销 总的来说优点远大于缺点，用过的都说好。 命令行订阅发布1234567# 进入qaweb容器，也可进入其他容器，大部分容器都安装了qapubsub，mgdb和eventmq除外docker exec -it qaweb bash# 订阅qaps_sub --exchange x1 --model fanout --host qaeventmq# 发布，新开一个命令行执行qaps_pub --exchange x1 --model fanout --content 111 --host qaeventmq# 发布后，订阅的命令行就会收到数据 Python代码123456789101112131415161718from QAPUBSUB.consumer import subscriber, subscriber_routing# 订阅名为x1的exchangesub = subscriber(exchange=&#x27;x1&#x27;)# 修改回调函数def on_data(a, b, c, data): print(&#x27;on_data: &#x27;, data) # 策略代码。。。sub.callback = on_data# 开启订阅# 1. 线程阻塞，需要订阅和发布在两个线程中执行# sub.start() # 2. 线程不阻塞import threadingthreading.Thread(target=sub.start).start() 123from QAPUBSUB.producer import publisher, publisher_routingpub = publisher(exchange=&#x27;x1&#x27;)pub.pub(&#x27;111&#x27;) # pub后上面的订阅就会收到 1234import QUANTAXIS as QAdf = QA.QA_fetch_get_future_day(&#x27;tdx&#x27;, &#x27;RBL8&#x27;, &#x27;2019-09-01&#x27;, &#x27;2019-09-30&#x27;)for idx, item in df.iterrows(): pub.pub(item.to_json()) GitHubhttps://github.com/yutiansut/QAPUBSUB","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]},{"title":"Docker安装","slug":"knowledge/编程/容器/Docker/Docker安装","date":"2021-11-13T17:52:11.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/e4809e342a40dd55/","link":"","permalink":"https://xiongyifan.github.io/knowledge/e4809e342a40dd55/","excerpt":"Ubuntu安装脚本wget下载脚本安装，脚本中包括安装docker，开启非root用户执行docker命令，修改docker源（腾讯）。 1curl -sSL https://gitee.com/xiongyifan/quantaxis-study/raw/master/bash/install_docker.sh | sh","text":"Ubuntu安装脚本wget下载脚本安装，脚本中包括安装docker，开启非root用户执行docker命令，修改docker源（腾讯）。 1curl -sSL https://gitee.com/xiongyifan/quantaxis-study/raw/master/bash/install_docker.sh | sh Window安装系统选择Win10专业版或者企业版：这两个版本有hyper-v功能，可以安装docker-ceWin10家庭版或ghost：家庭版没有hyper-v功能，ghost版本可能阉割了hyper-v，所以装不了docker-ceWin7：只能安装docker toolbox，本质是虚拟机，依赖多，而且从github上下载很慢。 安装过程中的问题安装过程中要选择linux container，而不是window container。否则会遇到docker-compose版本过旧的问题。","categories":[{"name":"Docker","slug":"Docker","permalink":"https://xiongyifan.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xiongyifan.github.io/tags/Docker/"}]},{"title":"QUANTAXIS脚本安装","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/QUANTAXIS脚本安装","date":"2021-11-13T17:52:09.000Z","updated":"2021-11-16T14:57:54.000Z","comments":true,"path":"knowledge/ebdfa7c933851e11/","link":"","permalink":"https://xiongyifan.github.io/knowledge/ebdfa7c933851e11/","excerpt":"Docker安装Docker安装 QUANTAXIS安装脚本根据天神的qa-service-pro修改，但只保留了7个基本的容器，qa，qaweb，mgdb，qaeventmq，qactpbeebroker，qamarketcollector，qatrader，后面需要时再增加。 通过wget下载脚本安装之前，需要先准备好群文件中的QA和pytdx，并与脚本放在同一个目录下。 12345mkdir QA # 创建目录存放docker-compose.yamlcd QA# 下载群文件中的QUANTAXIS和pytdx，放在QA目录下# 执行安装脚本curl -sSL https://gitee.com/xiongyifan/quantaxis-study/raw/master/bash/install_qa.sh | sh","text":"Docker安装Docker安装 QUANTAXIS安装脚本根据天神的qa-service-pro修改，但只保留了7个基本的容器，qa，qaweb，mgdb，qaeventmq，qactpbeebroker，qamarketcollector，qatrader，后面需要时再增加。 通过wget下载脚本安装之前，需要先准备好群文件中的QA和pytdx，并与脚本放在同一个目录下。 12345mkdir QA # 创建目录存放docker-compose.yamlcd QA# 下载群文件中的QUANTAXIS和pytdx，放在QA目录下# 执行安装脚本curl -sSL https://gitee.com/xiongyifan/quantaxis-study/raw/master/bash/install_qa.sh | sh QUANTAXIS初始化以下内容复制自QQ群公告第一次部署docker版QA必须的初始化操作步骤：一、在浏览器输入docker宿主机”ip地址:8888”；二、进入jupyterlab登录界面后输入口令”quantaxis”;三、进入jupyterlab启动页，点击Terminal进入终端；四、在终端界面输入”/bin/bash”,进入bash状态；五、bash状态输入”quantaxis”,进入数据库操作状态；六：依次输入完成数据库初始化“save stock_list”，”save single_index_day 000300”输入exit退出终端，在docker管理界面重启qaweb容器，最后浏览器输入docker宿主机”ip地址:81”，弹出的登录界面把登录地址端口改为docker宿主机”ip地址:8010”,就可以进入QA前端界面","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS-QARealtimeCollector行情订阅和二次采样组件","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/QUANTAXIS-QARealtimeCollector行情订阅和二次采样组件","date":"2021-11-13T17:52:08.000Z","updated":"2021-11-16T15:27:29.000Z","comments":true,"path":"knowledge/e5b8132e67d4490d/","link":"","permalink":"https://xiongyifan.github.io/knowledge/e5b8132e67d4490d/","excerpt":"QARealtimeCollector的作用QARealtimeCollector的作用有两个： 对实时tick数据进行二次采样，包括股票和期货。由QARC_WEBSERVER命令提供。 股票实时tick行情接入。由QARC_Stock提供，通过pytdx接入股票tick行情。 123# 命令行启动服务QARC_WEBSERVER # 提供http服务，进行股票和期货的订阅和二次采样QARC_Stock # 提供股票的tick行情","text":"QARealtimeCollector的作用QARealtimeCollector的作用有两个： 对实时tick数据进行二次采样，包括股票和期货。由QARC_WEBSERVER命令提供。 股票实时tick行情接入。由QARC_Stock提供，通过pytdx接入股票tick行情。 123# 命令行启动服务QARC_WEBSERVER # 提供http服务，进行股票和期货的订阅和二次采样QARC_Stock # 提供股票的tick行情 QARealtimeCollector安装步骤增加QARealtimeCollector模块在docker-compose.yaml中添加qamarketcollector模块 12345678910111213141516qamarketcollector: image: daocloud.io/quantaxis/qarealtimecollector:latest container_name: qamarketcollector ports: - &quot;8011:8011&quot; depends_on: - mgdb - qaeventmq environment: - MONGODB=mgdb - EventMQ_IP=qaeventmq networks: qanetwork_pro: ipv4_address: 172.19.3.8 command: [&#x27;/root/QUANTAXIS_RealtimeCollector/docker/wait_for_it.sh&#x27;, &#x27;qaeventmq:5672&#x27;, &#x27;--&#x27; ,&#x27;/root/QUANTAXIS_RealtimeCollector/docker/start_collector.sh&#x27;] command中指定的start_collector.sh脚本会执行QARC_WEBSERVER和QARC_Stock命令 启动如果是新添加的qamarketcollector，那么可以直接通过下面的命令启动。 1docker-compose up -d 如果之前已经跟其他模块一起启动的话，qamarketcollector模块会正常启动。 订阅分钟行情订阅地址：POST http://10.211.55.38:8011?action=new_handler&amp;market_type=future_cn&amp;code=rb2201 订阅成功后CTPX里面会增加一个rb2201，Exchange会增加realtime_min_rb2201和bar_1min_rb2201，然后命令行订阅就可以看到数据 12qaps_sub --exchange realtime_min_rb2201 --model fanoutqaps_sub --exchange bar_1min_rb2201 --model fanout 上面是realtime_min_rb2201的数据，下面是bar_1min_rb2201的数据。 二次采样x分钟数据POST http://10.211.55.38:8011?action=new_resampler&amp;market_type=future_cn&amp;code=rb2201&amp;frequence=5min 订阅成功后Exchange会增加一个realtime_5min_rb2201 1qaps_sub --exchange realtime_5min_rb2201 --model fanout 订阅股票tick数据POST http://10.211.55.38:8011?action=new_handler&amp;market_type=stock_cn&amp;code=000001 订阅成功后通过名为stocktransaction的exchange获取数据 1qaps_sub --exchange stocktransaction --model fanout http请求合集123456789101112# 订阅股票POST http://10.211.55.40:8011?action=new_handler&amp;market_type=stock_cn&amp;code=000001# 订阅期货POST http://10.211.55.40:8011?action=new_handler&amp;market_type=future_cn&amp;code=rb2201# 股票采样POST http://10.211.55.40:8011?action=new_resampler&amp;market_type=stock_cn&amp;code=000001&amp;frequence=5min# 期货采样POST http://10.211.55.40:8011?action=new_resampler&amp;market_type=future_cn&amp;code=rb2201&amp;frequence=5min# 现在的订阅POST http://10.211.55.40:8011?action=get_current_handler# 现在的采样POST http://10.211.55.40:8011?action=get_current_resampler GithubQUANTAXIS_RealtimeCollector 问题realtime_5min_rb2201的数据有，但是tradetime是错的，”tradetime”: “wrong date 22:36:30”，什么都没动，第二天的数据就正常了 股票数据出不来，原因是因为数据是从pytdx过来的，docker里的pytdx有问题，安装QQ群里的就好了","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS-QACTPBeeBroker实时行情组件","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/QUANTAXIS-QACTPBeeBroker实时行情组件","date":"2021-11-13T17:52:06.000Z","updated":"2021-11-16T15:27:34.000Z","comments":true,"path":"knowledge/50efbeb4d7a55858/","link":"","permalink":"https://xiongyifan.github.io/knowledge/50efbeb4d7a55858/","excerpt":"QACTPBeeBroker的作用通过QACTPBEE命令接入实时的tick行情，然后通过QAPUBSUB订阅就能获取到行情 1QACTPBEE --userid 133496 --password QCHL1234 下面的第1和第2步只是为了在docker中执行上面的命令，也可以本地安装QACTPBeeBroker后手动执行上面命令，订阅的步骤是一样的。 当用docker-compose的qactpbeebroker时，默认会执行QACTPBEE命令，如果又手动执行了QACTPBEE命令就会推送两组数据。如果想手动启动只能本地安装，注释掉docker-compose.yaml中的启动命令是没有用的，因为源码中有默认的账号密码。","text":"QACTPBeeBroker的作用通过QACTPBEE命令接入实时的tick行情，然后通过QAPUBSUB订阅就能获取到行情 1QACTPBEE --userid 133496 --password QCHL1234 下面的第1和第2步只是为了在docker中执行上面的命令，也可以本地安装QACTPBeeBroker后手动执行上面命令，订阅的步骤是一样的。 当用docker-compose的qactpbeebroker时，默认会执行QACTPBEE命令，如果又手动执行了QACTPBEE命令就会推送两组数据。如果想手动启动只能本地安装，注释掉docker-compose.yaml中的启动命令是没有用的，因为源码中有默认的账号密码。 QACTPBeeBroker接入实时行情的步骤1. 增加qactpbeebroker模块在docker-compose.yaml中添加qactpbeebroker模块 123456789101112131415161718qactpbeebroker: image: daocloud.io/quantaxis/qactpbeebroker:latest container_name: qactpbeebroker ports: - &quot;5000:5000&quot; networks: qanetwork_pro: ipv4_address: 172.19.3.7 # --userid TEXT # --password TEXT # --brokerid TEXT # --mdaddr TEXT # --tdaddr TEXT # --appid TEXT # --authcode TEXT command: [&#x27;/root/wait_for_it.sh&#x27;, &#x27;qaeventmq:15672&#x27;, &#x27;--&#x27; , &quot;QACTPBEE&quot;, &quot;--userid&quot;, &quot;133496&quot;, &quot;--password&quot;, &#x27;QCHL1234&#x27;] 如果想用自己的账户可以在command中修改userid和password。 2. 启动如果是新添加的qactpbeebroker，那么可以直接通过下面的命令启动。 1docker-compose up -d 如果之前已经跟其他模块一起启动的话，qactpbeebroker可能会启动失败，原因不明。解决办法，手动重新启动下就好了。 12docker ps # 没有qactpbeebroker的话，说明已经停止运行了docker-compose start qactpbeebroker # 没有的话，运行命令启动 3. 检查1docker logs --tail 1000 -f qactpbeebroker 如果日志显示连接成功，或者有在打印合约代码，说明接入成功了。 接入成功后，15672页面会增加名为CTPX的Exchange。但是由于Exchange失效后不会自动在15672页面消失，所以有CTPX不意味着连接成功，看日志更保险。 订阅tick行情订阅tick行情，大概每秒2条tick行情 1qaps_sub --exchange CTPX --model direct --routing_key rb2201 订阅成功后，命令行显示tick行情 并且名为CTPX的Exchange增加 CTPBEE的任务是连接实盘tick行情，分钟行情则需要使用QARealtimeCollector二次采样分发。 问题docker-compose up -d所有容器全部一起启动，qactpbeebroker会死掉，手动再启动就好了，不知道怎么回事 10:15~10:30 rb2201数据停了，是因为这15分钟不是交易时间 Githubhttps://github.com/ctpbee/ctpbeehttps://github.com/yutiansut/QACTPBeeBroker","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS实时数据模拟撮合","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/安装到实盘/QUANTAXIS实时数据模拟撮合","date":"2021-11-13T17:52:05.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/6e8f7a03cfbd89f6/","link":"","permalink":"https://xiongyifan.github.io/knowledge/6e8f7a03cfbd89f6/","excerpt":"整个流程与QUANTAXIS实时数据本地撮合有两点不同： 模拟撮合通过qatrader模块连接模拟盘账户完成订单。 账户查询操作通过数据库完成，而不是QAAccount 模拟账户接入QUANTAXIS-QATrader模拟和实盘交易组件 接入成功后，通过pub发单即可。","text":"整个流程与QUANTAXIS实时数据本地撮合有两点不同： 模拟撮合通过qatrader模块连接模拟盘账户完成订单。 账户查询操作通过数据库完成，而不是QAAccount 模拟账户接入QUANTAXIS-QATrader模拟和实盘交易组件 接入成功后，通过pub发单即可。 账户准备账户查询操作通过数据库完成，而不是QAAccountaccount_cookie是qatader命令指定的–accqatader执行成功后就可以在数据库查询到账户信息。 123456# 1. 账户准备account_cookie = &#x27;101010&#x27;db = pymongo.MongoClient(os.getenv(&#x27;MONGODB&#x27;)).QAREALTIMEdef find_acc(): return db.account.find_one(&#123;&#x27;account_cookie&#x27;: account_cookie&#125;)simacc = find_acc() 发单操作方法模拟账户通过pub到名为QAORDER_ROUTER的Exchange完成发单，而不是调用simple_deal。 为简化流程sendorder发单价格要高些，不然会出现多次买多等情况。 123456789101112131415pub = publisher_routing(exchange=&#x27;QAORDER_ROUTER&#x27;)def sendorder(code, price, order_direction, order_offset, volume): routing_key = account_cookie pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: account_cookie, &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: code, &#x27;price&#x27;: price, &#x27;order_direction&#x27;: order_direction, &#x27;order_offset&#x27;: order_offset, &#x27;volume&#x27;: volume, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;, &#125;), routing_key=routing_key) 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import QUANTAXIS as QAfrom QAPUBSUB.consumer import subscriberfrom QAPUBSUB.producer import publisher, publisher_routingimport threading, json, pymongo, os, datetimeimport pandas as pd# 1. 账户准备account_cookie = &#x27;marco07281&#x27;db = pymongo.MongoClient(os.getenv(&#x27;MONGODB&#x27;)).QAREALTIMEdef find_acc(): return db.account.find_one(&#123;&#x27;account_cookie&#x27;: account_cookie&#125;)simacc = find_acc()# 2. 发单操作方法BUY = &#x27;BUY&#x27;SELL = &#x27;SELL&#x27;OPEN = &#x27;OPEN&#x27;CLOSETODAY = &#x27;CLOSETODAY&#x27;pub = publisher_routing(exchange=&#x27;QAORDER_ROUTER&#x27;)def sendorder(code, price, order_direction, order_offset, volume): routing_key = account_cookie pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: account_cookie, &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: code, &#x27;price&#x27;: price, &#x27;order_direction&#x27;: order_direction, &#x27;order_offset&#x27;: order_offset, &#x27;volume&#x27;: volume, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;, &#125;), routing_key=routing_key)# 3. 策略market_data_list = []def on_data(a, b, c, data): # 数据准备 bar = json.loads(data) market_data_list.append(bar) market_data_df = pd.DataFrame(market_data_list).set_index(&#x27;datetime&#x27;, drop=False) # 计算指标 ind = QA.QA_indicator_MA(market_data_df, 2, 4) print(ind) # 策略逻辑 MA2 = ind.iloc[-1][&#x27;MA2&#x27;] MA4 = ind.iloc[-1][&#x27;MA4&#x27;] code = bar[&#x27;code&#x27;].lower() trade_price = bar[&#x27;close&#x27;] trade_amount = 1 trade_time = bar[&#x27;datetime&#x27;] simacc = find_acc() positions = simacc[&#x27;positions&#x27;] code_key = &#x27;SHFE_&#x27; + &#x27;rb2201&#x27; volume_long = positions[code_key][&#x27;volume_long&#x27;] if code_key in positions else 0 volume_short = positions[code_key][&#x27;volume_short&#x27;] if code_key in positions else 0 print(MA2, MA4, code, trade_price, trade_time, volume_long, volume_short) if MA2 &gt; MA4: # 先平空，否则会先执行买多，就会不会平空了 if volume_short &gt; 0: print(&#x27;平空&#x27;) sendorder(code, trade_price + 5, BUY, CLOSETODAY, trade_amount) if volume_long == 0: print(&#x27;买多&#x27;) sendorder(code, trade_price + 5, BUY, OPEN, trade_amount) elif volume_long &gt; 0: print(&#x27;持有&#x27;) elif MA4 &gt; MA2: if volume_long &gt; 0: print(&#x27;平多&#x27;) sendorder(code, trade_price - 5, SELL, CLOSETODAY, trade_amount) if volume_short == 0: print(&#x27;卖空&#x27;) sendorder(code, trade_price - 5, SELL, OPEN, trade_amount) elif volume_short &gt; 0: print(&#x27;持有&#x27;) else: print(&#x27;不操作&#x27;)# 3. 订阅数据sub = subscriber(exchange=&#x27;bar_1min_rb2201&#x27;)sub.callback=on_datathreading.Thread(target=sub.start).start()","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS实时数据本地撮合","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/安装到实盘/QUANTAXIS实时数据本地撮合","date":"2021-11-13T17:52:04.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/1b4999756a5fe616/","link":"","permalink":"https://xiongyifan.github.io/knowledge/1b4999756a5fe616/","excerpt":"实时tick数据接入QUANTAXIS-QACTPBeeBroker实时行情组件 实时tick数据接入后，就可以进行二次采样 二次采样数据QUANTAXIS-QARealtimeCollector行情订阅和二次采样组件 订阅rb2201成功后，下面通过bar_1min_rb2201做策略","text":"实时tick数据接入QUANTAXIS-QACTPBeeBroker实时行情组件 实时tick数据接入后，就可以进行二次采样 二次采样数据QUANTAXIS-QARealtimeCollector行情订阅和二次采样组件 订阅rb2201成功后，下面通过bar_1min_rb2201做策略 创建用户账户的account_cookie改成了test_realtime_simpledeal，测试实时数据simpledeal撮合。 1acc = port.new_account(&#x27;test_realtime_simpledeal&#x27;, 100000, QA.MARKET_TYPE.FUTURE_CN) 策略set_index的date，改成了datetime，之前本地数据用的日线的date，现在是1分钟实时数据用的是datetime 1market_data_df = pd.DataFrame(market_data_list).set_index(&#x27;datetime&#x27;, drop=False) trade_time改成datetime，之前本地数据用的日线的date+’ 00:00:00’，现在1分钟实时数据直接用datetime 1trade_time = bar[&#x27;datetime&#x27;] 数据是实时推送的，不能在所有代码执行完毕后查看结果。所以在策略的最后保存了acc，可随时通过代码或数据库查看交易情况。 1acc.save() 订阅数据exchange改成了bar_1min_rb2201，之前的exchange是自己命名的，现在订阅的是实时1分钟的螺纹钢 1sub = subscriber(exchange=&#x27;bar_1min_rb2201&#x27;) 数据获取并推送数据这块代码不需要了。数据是CTPX主动推送的，所以只需要在上面订阅好需要数据就行。 查看和保存结果这两块也不需要了，数据是慢慢推过来的，想看阶段结果就用acc查看即可。 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import QUANTAXIS as QAfrom QAPUBSUB.consumer import subscriberfrom QAPUBSUB.producer import publisherimport threading, jsonimport pandas as pd# 1. 账户准备user = QA.QA_User(username=&#x27;admin&#x27;, password=&#x27;admin&#x27;)port = user.new_portfolio(&#x27;x1&#x27;)acc = port.new_account(&#x27;test_realtime_simpledeal&#x27;, 100000, QA.MARKET_TYPE.FUTURE_CN)# 2. 发单操作方法def sendorder(code, trade_price, trade_towards, trade_time): acc.receive_simpledeal( code=code, trade_price=trade_price, trade_amount=trade_amount, trade_towards=trade_towards, trade_time=trade_time)# 3. 策略market_data_list = []def on_data(a, b, c, data): # 数据准备 bar = json.loads(data) market_data_list.append(bar) market_data_df = pd.DataFrame(market_data_list).set_index(&#x27;datetime&#x27;, drop=False) # 计算指标 ind = QA.QA_indicator_MA(market_data_df, 2, 4) print(ind) # 策略逻辑 MA2 = ind.iloc[-1][&#x27;MA2&#x27;] MA4 = ind.iloc[-1][&#x27;MA4&#x27;] code = bar[&#x27;code&#x27;] trade_price = bar[&#x27;close&#x27;] trade_amount = 1 trade_time = bar[&#x27;datetime&#x27;] code_hold_available = acc.hold_available.get(code, 0) if MA2 &gt; MA4: if code_hold_available == 0: print(&#x27;买多&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.BUY_OPEN, trade_time) elif code_hold_available &gt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平空&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.BUY_CLOSE, trade_time) elif MA4 &gt; MA2: if code_hold_available == 0: print(&#x27;卖空&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.SELL_OPEN, trade_time) elif code_hold_available &lt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平多&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.SELL_CLOSE, trade_time) else: print(&#x27;不操作&#x27;) # 保存结果 acc.save() # 4. 订阅数据sub = subscriber(exchange=&#x27;bar_1min_rb2201&#x27;)sub.callback=on_datathreading.Thread(target=sub.start).start()","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS从安装到实盘","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/安装到实盘/QUANTAXIS从安装到实盘","date":"2021-11-13T17:52:03.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/c5bed9ec3b959bfd/","link":"","permalink":"https://xiongyifan.github.io/knowledge/c5bed9ec3b959bfd/","excerpt":"","text":"内容整理自天神的视频，目前更新到STU02 系统环境：Ubuntu 20.04 QUANTAXIS脚本安装QUANTAXIS脚本安装 QUANTAXIS本地数据本地撮合QUANTAXIS本地数据本地撮合 QUANTAXIS实时数据本地撮合QUANTAXIS实时数据本地撮合 QUANTAXIS实时数据模拟撮合QUANTAXIS实时数据模拟撮合 QUANTAXIS实时数据实盘交易待完成","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS本地数据本地撮合","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/安装到实盘/QUANTAXIS本地数据本地撮合","date":"2021-11-13T17:52:02.000Z","updated":"2021-11-16T09:15:46.000Z","comments":true,"path":"knowledge/d1be47f9274e8671/","link":"","permalink":"https://xiongyifan.github.io/knowledge/d1be47f9274e8671/","excerpt":"QUANTAXIS本地数据本地撮合，以及后面的模拟到实盘，都基于QAPUBSUB实现。 QAPUBSUBQUANTAXIS-QAPUBSUB消息订阅组件 数据准备1234# 打开8888页面，开启一个命令行，执行下面3个命令/bin/bashquantaxissave single_future_day RBL8","text":"QUANTAXIS本地数据本地撮合，以及后面的模拟到实盘，都基于QAPUBSUB实现。 QAPUBSUBQUANTAXIS-QAPUBSUB消息订阅组件 数据准备1234# 打开8888页面，开启一个命令行，执行下面3个命令/bin/bashquantaxissave single_future_day RBL8 import依赖123456import QUANTAXIS as QAfrom QAPUBSUB.consumer import subscriber # 消费者from QAPUBSUB.producer import publisher # 生产者import threading # 在线程中运行消费者，防止线程阻塞import json # 消费者接收的数据是文本，转成jsonimport pandas as pd # json转成DataFrame 账户准备用户(User) -&gt; 组合(Portfolio) -&gt; 账户(Account)一个用户下面可以有多个组合，一个组合下面可以有多个账户，实际交易的是账户。就像一个基金经理，操作多个投资组合，一个投资组合分多个策略，在不同的账户中执行。 123456# 1. 账户准备user = QA.QA_User(username=&#x27;admin&#x27;, password=&#x27;admin&#x27;) # 账号密码跟81页面登录的账号密码一致# portfolio_cookie就像是组合的idport = user.new_portfolio(portfolio_cookie=&#x27;x1&#x27;)# account_cookie就像是账户的id，init_cash是账户的初始资金，market_type为市场类型，QA中通过market_type预设了交易规则，例如期货允许t0等，与国内的交易规则一致。acc = port.new_account(account_cookie=&#x27;test_local_simpledeal&#x27;, init_cash=100000, market_type=QA.MARKET_TYPE.FUTURE_CN) 发单操作方法发单用的是QAAccount的receive_simpledeal方法，这个方法会直接完成撮合，一定成交。而模拟盘和实盘使用的是QATrader，根据实时行情撮合，不一定成交。 12345678# 2. 发单操作方法def sendorder(code, trade_price, trade_amount, trade_towards, trade_time): acc.receive_simpledeal( code=code, trade_price=trade_price, trade_amount=trade_amount, trade_towards=trade_towards, trade_time=trade_time) 策略MA2 &gt; MA4：买多，有多头仓平空MA4 &gt; MA2：卖空，有空头仓平多 123456789101112131415161718192021222324252627282930313233343536373839404142# 3. 策略market_data_list = [] # 存储历史数据# 下面订阅数据时会指定on_data为回调函数，接到数据就会执行on_datadef on_data(a, b, c, data): # 数据准备 bar = json.loads(data) market_data_list.append(bar) # 日线date格式是2019-01-01 market_data_df = pd.DataFrame(market_data_list).set_index(&#x27;date&#x27;, drop=False) # 计算指标 ind = QA.QA_indicator_MA(market_data_df, 2, 4) # 计算MA2和MA4 print(ind) # 策略逻辑 MA2 = ind.iloc[-1][&#x27;MA2&#x27;] # 取最新的MA2 MA4 = ind.iloc[-1][&#x27;MA4&#x27;] # 取最新的MA4 code = bar[&#x27;code&#x27;] # 合约代码 trade_price = bar[&#x27;close&#x27;] # 最新收盘价 trade_amount = 1 # 1手 trade_time = bar[&#x27;date&#x27;] + &#x27; 00:00:00&#x27; # 由于日线date的格式是2019-01-01，所以要加后面的时间，否则无法计算指标，后面的问题章节有详细说明。 code_hold_available = acc.hold_available.get(code, 0) # 合约目前的持仓情况 if MA2 &gt; MA4: if code_hold_available == 0: print(&#x27;买多&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.BUY_OPEN, trade_time) elif code_hold_available &gt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平空&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.BUY_CLOSE, trade_time) elif MA4 &gt; MA2: if code_hold_available == 0: print(&#x27;卖空&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.SELL_OPEN, trade_time) elif code_hold_available &lt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平多&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.SELL_CLOSE, trade_time) else: print(&#x27;不操作&#x27;) 订阅数据1234# 4. 订阅数据sub = subscriber(exchange=&#x27;x1&#x27;) # Exchange名为x1，在15672页面能看到sub.callback=on_data # 指定回调函数threading.Thread(target=sub.start).start() # 开线程执行订阅，防止线程阻塞，后面的发布代码无法执行 数据获取并推送数据1234567# 5. 数据获取并推送数据# 获取df = QA.QA_fetch_get_future_day(&#x27;tdx&#x27;, &#x27;RBL8&#x27;, &#x27;2019-08-01&#x27;, &#x27;2019-08-30&#x27;)# 推送pub = publisher(exchange=&#x27;x1&#x27;) # 跟订阅的Exchange一致for idx, item in df.iterrows(): pub.pub(item.to_json()) # 每行数据换成json，pub出去，上面的on_data就会收到，开始执行策略。 查看结果1234567# 6. 查看结果risk = QA.QA_Risk(acc)performance = QA.QA_Performance(acc)acc.history_table # 交易记录risk.plot_assets_curve() # 资产曲线performance.pnl # 盈利情况 保存结果12# 7. 保存结果risk.save() risk保存后，81页面查看回测结果。绩效分析结果没有。 1acc.save() 保存acc后，再看81页面，绩效分析就开始转圈，原因不明。 完整代码jupyter notebook 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/usr/bin/env python# coding: utf-8import QUANTAXIS as QAfrom QAPUBSUB.consumer import subscriber # 消费者from QAPUBSUB.producer import publisher # 生产者import threading # 在线程中运行消费者，防止线程阻塞import json # 消费者接收的数据是文本，转成jsonimport pandas as pd # json转成DataFrame# 1. 账户准备user = QA.QA_User(username=&#x27;admin&#x27;, password=&#x27;admin&#x27;) # 账号密码跟81页面登录的账号密码一致# portfolio_cookie就像是组合的idport = user.new_portfolio(portfolio_cookie=&#x27;x1&#x27;)# account_cookie就像是账户的id，init_cash是账户的初始资金，market_type为市场类型，QA中通过market_type预设了交易规则，例如期货允许t0等，与国内的交易规则一致。acc = port.new_account(account_cookie=&#x27;test_local_simpledeal&#x27;, init_cash=100000, market_type=QA.MARKET_TYPE.FUTURE_CN)# 2. 发单操作方法def sendorder(code, trade_price, trade_amount, trade_towards, trade_time): acc.receive_simpledeal( code=code, trade_price=trade_price, trade_amount=trade_amount, trade_towards=trade_towards, trade_time=trade_time)# 3. 策略market_data_list = [] # 存储历史数据# 下面订阅数据时会指定on_data为回调函数，接到数据就会执行on_datadef on_data(a, b, c, data): # 数据准备 bar = json.loads(data) market_data_list.append(bar) # 日线date格式是2019-01-01 market_data_df = pd.DataFrame(market_data_list).set_index(&#x27;date&#x27;, drop=False) # 计算指标 ind = QA.QA_indicator_MA(market_data_df, 2, 4) # 计算MA2和MA4 print(ind) # 策略逻辑 MA2 = ind.iloc[-1][&#x27;MA2&#x27;] # 取最新的MA2 MA4 = ind.iloc[-1][&#x27;MA4&#x27;] # 取最新的MA4 code = bar[&#x27;code&#x27;] # 合约代码 trade_price = bar[&#x27;close&#x27;] # 最新收盘价 trade_amount = 1 # 1手 trade_time = bar[&#x27;date&#x27;] + &#x27; 00:00:00&#x27; # 由于日线date的格式是2019-01-01，所以要加后面的时间，否则无法计算指标，后面的问题章节有详细说明。 code_hold_available = acc.hold_available.get(code, 0) # 合约目前的持仓情况 if MA2 &gt; MA4: if code_hold_available == 0: print(&#x27;买多&#x27;) sendorder(code, trade_price, trade_amount, QA.ORDER_DIRECTION.BUY_OPEN, trade_time) elif code_hold_available &gt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平空&#x27;) sendorder(code, trade_price, trade_amount, QA.ORDER_DIRECTION.BUY_CLOSE, trade_time) elif MA4 &gt; MA2: if code_hold_available == 0: print(&#x27;卖空&#x27;) sendorder(code, trade_price, trade_amount, QA.ORDER_DIRECTION.SELL_OPEN, trade_time) elif code_hold_available &lt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平多&#x27;) sendorder(code, trade_price, trade_amount, QA.ORDER_DIRECTION.SELL_CLOSE, trade_time) else: print(&#x27;不操作&#x27;)# 4. 订阅数据sub = subscriber(exchange=&#x27;x1&#x27;) # Exchange名为x1，在15672页面能看到sub.callback=on_data # 指定回调函数threading.Thread(target=sub.start).start() # 开线程执行订阅，防止线程阻塞，后面的发布代码无法执行# 5. 数据获取并推送数据# 获取df = QA.QA_fetch_get_future_day(&#x27;tdx&#x27;, &#x27;RBL8&#x27;, &#x27;2019-08-01&#x27;, &#x27;2019-08-30&#x27;)# 推送pub = publisher(exchange=&#x27;x1&#x27;) # 跟订阅的Exchange一致for idx, item in df.iterrows(): pub.pub(item.to_json()) # 每行数据换成json，pub出去，上面的on_data就会收到，开始执行策略。# 6. 查看结果risk = QA.QA_Risk(acc)performance = QA.QA_Performance(acc)acc.history_table # 交易记录risk.plot_assets_curve() # 资产曲线performance.pnl # 盈利情况# 7. 保存结果risk.save()acc.save() 问题 需要先存数据，因为qa_risk会调用QA_fetch_stock_day_adv，这个方法会从数据库读数据，读不到数据后面的指标不能计算（已解决） receive_simpledeal的trade_time，要用%Y-%m-%d %H:%M:%S格式，因为history_min会用到这个格式，格式不对会计算不出history_min，导致后面指标不能计算。（已解决） 在存了数据，trade_time写对之后，performance.pnl等等都能计算出来了，但是81界面的绩效分析就是出不来，不知道为什么（未解决） acc = port.new_account(‘test1’, 100000, QA.MARKET_TYPE.FUTURE_CN, auto_reload=False)，跑第一次的时候会把acc存在数据库，第二次再跑的时候，创建的acc，market_type会变成stock_cn，因为走的else代码块，创建走的if，具体看QAPortfolio的第385行。但是如果auto_reload是true的话就不会有问题，因为会从数据库读取覆盖掉创建时赋值的参数，缺点是交易数据的累计的，跑不同的数据，交易记录会混在一起。（未解决）","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS-QATrader模拟和实盘交易组件","slug":"knowledge/投资/量化投资/编程/QUANTAXIS/QUANTAXIS-QATrader模拟和实盘交易组件","date":"2021-11-13T17:52:01.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/065307546a65df5c/","link":"","permalink":"https://xiongyifan.github.io/knowledge/065307546a65df5c/","excerpt":"模拟盘启动模拟账户123456# 进入qatrader容器docker exec -it qatrader /bin/bash# 开启模拟盘账户# 当指定一个新的acc执行这个命令时，会创建一个acc，存在数据库中# 已经创建过的acc可以在81页面查看，但是必须开启qatrader才能交易qatrader --acc 101010 --pwd 101010 --broker QUANTAXIS","text":"模拟盘启动模拟账户123456# 进入qatrader容器docker exec -it qatrader /bin/bash# 开启模拟盘账户# 当指定一个新的acc执行这个命令时，会创建一个acc，存在数据库中# 已经创建过的acc可以在81页面查看，但是必须开启qatrader才能交易qatrader --acc 101010 --pwd 101010 --broker QUANTAXIS 输出下图日志就说明启动成功 同时RabbitMQ中会增加3个Exchange Exchange QAORDER_ROUTER增加账户信息 启动问题qatrader报参数个数错误，原因是python版本错误，应该用python3.6或3.7 qatrader报socket is already closed，原因是因为电脑刚刚从睡眠状态唤醒，需要等一会儿或者重启 在81页面中查看模拟账户 向模拟账户下单首先下单前要明确一个概念，模拟盘下单就像是在同花顺的模拟账户中操作，所以下单数据都是跟实盘一样的，除了资金是虚拟。 12345678910111213141516171819from QAPUBSUB.producer import publisher_routingimport datetime# 向模拟盘下单使用的是publisher_routing，而不是publisherpub = publisher_routing(exchange=&#x27;QAORDER_ROUTER&#x27;)# 卖空pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: &#x27;101010&#x27;, # 账户名 &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: &#x27;rb2201&#x27;, &#x27;price&#x27;: 3816, &#x27;order_direction&#x27;: &#x27;SELL&#x27;, &#x27;order_offset&#x27;: &#x27;OPEN&#x27;, &#x27;volume&#x27;: 1, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;,&#125;), routing_key=&#x27;101010&#x27;) # 账户名 发单后就可以在模拟账户中查看 下单问题 合约不合法，表示code参数有问题，code参数不能是指数或连续或过期合约，例如螺纹指数合约RBL8，2020年1月的螺纹合约RB2001 查看持仓和委托等信息123456789101112import pymongoimport os# 连接数据库db = pymongo.MongoClient(os.getenv(&#x27;MONGODB&#x27;)).QAREALTIME# 查到账户simacc = db.account.find_one(&#123;&#x27;account_cookie&#x27;: &#x27;101010&#x27;&#125;)# 获取委托信息simacc[&#x27;orders&#x27;]# 获取成交信息simacc[&#x27;trades&#x27;]# 获取持仓simacc[&#x27;positions&#x27;] 取消委托12345pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;cancel_order&#x27;, &#x27;account_cookie&#x27;: &#x27;101010&#x27;, # 账户名 &#x27;order_id&#x27;: &#x27;QAOTG_jHEJZXWk&#x27;,&#125;), routing_key=&#x27;101010&#x27;) # 账户名 问题，event显示撤单成功，但是orders里面还是显示ALIVE，难道是因为在非交易时间发起的撤单？ 多账户下单 同一个signal，只需要修改account就可以实现多账户下单，并且可以同时向模拟盘和实盘下单 12345678910111213for acc in [&#x27;101010&#x27;, &#x27;202020&#x27;]: pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: acc, # 账户名 &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: &#x27;rb2201&#x27;, &#x27;price&#x27;: 3816, &#x27;order_direction&#x27;: &#x27;SELL&#x27;, &#x27;order_offset&#x27;: &#x27;OPEN&#x27;, &#x27;volume&#x27;: 1, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;, &#125;), routing_key=acc) # 账户名 Http请求下单 Http下单跟Python下单一样，实际都是向名为QAORDER_ROUTER的Exchange发送信息。 首先开启qatraderserver，提供Http服务 12# docker版本的qatrader默认会启动qatraderserver，所以可以不用再手动启动，配置启动qatraderserver的位置在docker-compose.yaml中qatraderserver # 再次启动，报端口占用 接口查看https://github.com/yutiansut/QATrader 实盘下单操作汇总卖空123456789101112pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: &#x27;101010&#x27;, # 账户名 &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: &#x27;rb2201&#x27;, &#x27;price&#x27;: 3816, &#x27;order_direction&#x27;: &#x27;SELL&#x27;, &#x27;order_offset&#x27;: &#x27;OPEN&#x27;, &#x27;volume&#x27;: 1, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;,&#125;), routing_key=&#x27;101010&#x27;) # 账户名 平今多123456789101112pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: &#x27;101010&#x27;, # 账户名 &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: &#x27;rb2201&#x27;, &#x27;price&#x27;: 3816, &#x27;order_direction&#x27;: &#x27;SELL&#x27;, &#x27;order_offset&#x27;: &#x27;CLOSETODAY&#x27;, &#x27;volume&#x27;: 1, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;,&#125;), routing_key=&#x27;101010&#x27;) # 账户名 取消委托12345pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;cancel_order&#x27;, &#x27;account_cookie&#x27;: &#x27;101010&#x27;, # 账户名 &#x27;order_id&#x27;: &#x27;QAOTG_jHEJZXWk&#x27;,&#125;), routing_key=&#x27;101010&#x27;) # 账户名 实盘账户数据库说明https://doc.shinnytech.com/tqsdk2/latest/reference/tqsdk2.objs.position.html 持仓说明simacc[‘positions’][‘SHFE_rb2201’] 123456789101112131415161718192021222324252627282930313233343536373839&#123;&#x27;user_id&#x27;: &#x27;marco07281&#x27;, # qatrader命令的--acc指定的用户名 &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;, # 交易所id &#x27;instrument_id&#x27;: &#x27;rb2201&#x27;, # 合约名称 &#x27;volume_long_today&#x27;: 1, # 今日下单的多单 &#x27;volume_long_his&#x27;: 0, # 历史持有的多单 &#x27;volume_long&#x27;: 1, # 总多单 = 今日 + 历史 &#x27;volume_long_frozen_today&#x27;: 0, &#x27;volume_long_frozen_his&#x27;: 0, &#x27;volume_long_frozen&#x27;: 0, &#x27;volume_short_today&#x27;: 0, &#x27;volume_short_his&#x27;: 0, &#x27;volume_short&#x27;: 0, &#x27;volume_short_frozen_today&#x27;: 0, &#x27;volume_short_frozen_his&#x27;: 0, &#x27;volume_short_frozen&#x27;: 0, &#x27;volume_long_yd&#x27;: 0, &#x27;volume_short_yd&#x27;: 0, &#x27;pos_long_his&#x27;: 0, &#x27;pos_long_today&#x27;: 1, # 跟volume_long_today一样？ &#x27;pos_short_his&#x27;: 0, &#x27;pos_short_today&#x27;: 0, &#x27;open_price_long&#x27;: 4249.0, # 多仓均价？ &#x27;open_price_short&#x27;: 0.0, &#x27;open_cost_long&#x27;: 42490.0, # 持有的多单总成本？ &#x27;open_cost_short&#x27;: 0.0, &#x27;position_price_long&#x27;: 4249.0, # 跟open_price_long有什么区别？ &#x27;position_price_short&#x27;: 0.0, &#x27;position_cost_long&#x27;: 42490.0, # 跟open_cost_long有什么区别？ &#x27;position_cost_short&#x27;: 0.0, &#x27;last_price&#x27;: 4262.0, # 实时的价格，会跟着行情一直变 &#x27;float_profit_long&#x27;: 130.0, # 实时的多单浮盈？ &#x27;float_profit_short&#x27;: 0.0, # 实时的空单浮盈？ &#x27;float_profit&#x27;: 130.0, # 实时浮盈 &#x27;position_profit_long&#x27;: 130.0, # 跟float_profit_long有什么区别 &#x27;position_profit_short&#x27;: 0.0, &#x27;position_profit&#x27;: 130.0, # 跟float_profit有什么区别 &#x27;margin_long&#x27;: 3308.8, # 多单保证金 &#x27;margin_short&#x27;: 0.0, # 空单保证金 &#x27;margin&#x27;: 3308.8&#125; # 总保证金","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"}]}],"categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/categories/QUANTAXIS/"},{"name":"Docker","slug":"Docker","permalink":"https://xiongyifan.github.io/categories/Docker/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiongyifan.github.io/tags/QUANTAXIS/"},{"name":"Docker","slug":"Docker","permalink":"https://xiongyifan.github.io/tags/Docker/"}]}
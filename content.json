{"meta":{"title":"小帆的帆的博客","subtitle":"小帆的博客","description":"量化小白","author":"小帆的帆","url":"https://xiaofan.art","root":"/"},"pages":[{"title":"分类","date":"2021-11-16T15:18:35.000Z","updated":"2021-11-16T15:18:59.952Z","comments":false,"path":"categories/index.html","permalink":"https://xiaofan.art/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-06-05T02:59:53.470Z","updated":"2022-06-05T02:41:43.125Z","comments":true,"path":"baidu_verify_code-BcgIUJ7jkU.html","permalink":"https://xiaofan.art/baidu_verify_code-BcgIUJ7jkU.html","excerpt":"","text":"133389211c2cfb5ac13c3680b68129c0"},{"title":"tags","date":"2021-11-14T10:09:05.000Z","updated":"2021-11-14T10:14:54.737Z","comments":false,"path":"tags/index.html","permalink":"https://xiaofan.art/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Plotly-k线图多行多列","slug":"knowledge/投资/量化投资/编程/Plotly/Plotly-k线图多行多列","date":"2022-06-05T00:20:55.000Z","updated":"2022-06-05T00:20:58.000Z","comments":true,"path":"knowledge/0912c144d0f8fe0a/","link":"","permalink":"https://xiaofan.art/knowledge/0912c144d0f8fe0a/","excerpt":"","text":"效果图 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import pandas as pdimport plotly.graph_objects as gofrom plotly.subplots import make_subplotsfrom math import ceildef plot_k_charts(data, cols, titles, data_columns=None): if data_columns is None: data_columns = [&#x27;date&#x27;, &#x27;open&#x27;, &#x27;high&#x27;, &#x27;low&#x27;, &#x27;close&#x27;, &#x27;volume&#x27;] rows = ceil(len(data) / cols) * 2 # 股票个数 / 行数, 乘2是给成交量的, 每个股票会占用两行 # 子图的参数 # 生成标题 subplot_titles = [] for i, title in enumerate(titles): if i % cols == 0 and len(subplot_titles) &gt; 0: subplot_titles.extend([&#x27;&#x27;] * cols) # 成交量空标题 subplot_titles.append(title) # 子图每行的长度, 跟specs中设置内边距会有冲突, 两个都设置会导致子图过多(24个)时出现显示错误 # row_width = [0.4, 0.6] * int(rows / 2) # 生成间距 specs = [] for i in range(rows): if i % 2 == 0: specs.append([&#123;&#x27;b&#x27;: 0.003&#125;] * cols) # k线行底部内边距 else: specs.append([&#123;&#x27;b&#x27;: 0.03&#125;] * cols) # 成交量底部内边距, 控制内边距会使子图的显示区域变窄, 同时又看起来拉大了间距 # 创建子图 fig = make_subplots(rows=rows, cols=cols, subplot_titles=subplot_titles, vertical_spacing=0.0, # 统一使用specs来控制间距 shared_xaxes=True, # row_width=row_width, specs=specs ) # k线的行, 例如: 1, 3, 5, 都是奇数行 row_index = list(range(1, rows)) row_index = row_index[::2] # 取奇数 for i, title in enumerate(titles): data_i = data[i] row = row_index[int(i / cols)] # row = int(i / 3) + 1 col = i % cols + 1 fig.add_trace( go.Candlestick(x=data_i[data_columns[0]], open=data_i[data_columns[1]], high=data_i[data_columns[2]], low=data_i[data_columns[3]], close=data_i[data_columns[4]], name=title), row=row, col=col # 第一行第一列 ) # 成交量的行, 在k线的基础上加1 fig.add_trace(go.Bar(x=data_i[data_columns[0]], y=data_i[data_columns[5]], showlegend=False), row + 1, col) # 在这里设置也不行, 还是会显示缩略图 # fig.update(layout_xaxis_rangeslider_visible=False) # rangeslider_visible可能是全局的, layout_xaxis_rangeslider_visible不好使了 fig.update_xaxes(rangeslider_visible=False) # fig.update(layout_xaxis_rangeslider_visible=False) # 调整画布高度 fig.update_layout( height=rows / 2 * 300, ) fig.show()if __name__ == &#x27;__main__&#x27;: df = pd.read_csv(&#x27;https://raw.githubusercontent.com/xiongyifan/QUANTAXIS-Study/master/data/600132-2020.csv&#x27;) df[&#x27;date&#x27;] = df[&#x27;date&#x27;].apply(lambda x: x.replace(&#x27;-&#x27;, &#x27;/&#x27;)) df = df.iloc[:50] # 只取前50条数据 plot_k_charts([df] * 24, cols=3, titles=[&#x27;000001.SZ&#x27;] * 24) # columns = [&quot;Date&quot;, &quot;AAPL.Open&quot;, &quot;AAPL.High&quot;, &quot;AAPL.Low&quot;, &quot;AAPL.Close&quot;, &#x27;AAPL.Volume&#x27;] # plot_k_charts([df] * 24, cols=3, titles=[&#x27;000001.SZ&#x27;] * 24, data_columns=columns) 相关文章Plotly-k线图过滤非交易时间Plotly-k线蜡烛图添加成交量","categories":[{"name":"Plotly","slug":"Plotly","permalink":"https://xiaofan.art/categories/Plotly/"}],"tags":[{"name":"Plotly","slug":"Plotly","permalink":"https://xiaofan.art/tags/Plotly/"}]},{"title":"Plotly-k线图过滤非交易时间","slug":"knowledge/投资/量化投资/编程/Plotly/Plotly-k线图过滤非交易时间","date":"2022-05-31T07:56:26.000Z","updated":"2022-05-31T07:56:26.000Z","comments":true,"path":"knowledge/dbde911451031ffa/","link":"","permalink":"https://xiaofan.art/knowledge/dbde911451031ffa/","excerpt":"","text":"Plotly默认显示所以日期, 所以非交易日就会是空白, 像是这样. 上图代码如下: 12345678910111213141516171819202122232425import pandas as pd import plotly.graph_objects as go from plotly.subplots import make_subplots # 数据 df = pd.read_csv(&#x27;https://raw.githubusercontent.com/xiongyifan/QUANTAXIS-Study/master/data/600132-2020.csv&#x27;) # df[&#x27;date&#x27;] = df[&#x27;date&#x27;].apply(lambda x: x.replace(&#x27;-&#x27;, &#x27;/&#x27;)) df = df[:100] # 创建子图 fig = make_subplots(rows=2, cols=1, shared_xaxes=True, subplot_titles=(&#x27;重庆啤酒&#x27;, &#x27;成交量&#x27;), row_width=[0.2, 0.7], vertical_spacing=0.05) # k线 fig.add_trace(go.Candlestick(x=df[&quot;date&quot;], open=df[&quot;open&quot;], high=df[&quot;high&quot;], low=df[&quot;low&quot;], close=df[&quot;close&quot;], name=&quot;重庆啤酒&quot;), row=1, col=1) # 成交量 fig.add_trace(go.Bar(x=df[&#x27;date&#x27;], y=df[&#x27;volume&#x27;], showlegend=False), row=2, col=1) # 不显示区间条 fig.update(layout_xaxis_rangeslider_visible=False) fig.show() 过滤方法方法1, 让Plotly不认为提供的时期当提供的日期格式为2020-01-01这种时, 会被识别为日期. 如果修改日期格式为2020/01/01, 则不会识别为日期, 就没有非交易日空白问题. 去掉上面代码中, 第8行的注释, 将日期的中 - 换成 / . 1df[&#x27;date&#x27;] = df[&#x27;date&#x27;].apply(lambda x: x.replace(&#x27;-&#x27;, &#x27;/&#x27;)) 运行结果如下: 这样处理起来还是挺简单的, 就是x轴的日期密密麻麻的. 可以修改x轴刻度, 有兴趣的朋友可以研究下. plotly绘图时设置X轴刻度标签_小黄油块跑的博客 方法2, 使用Plotly提供的过滤方法自己提供非交易日的列表, Plotly则会不显示这些日期. 123456789# 获取非交易日期列表date_broken = get_date_broken(start, end) # 过滤非交易时间fig.update_xaxes( rangebreaks=[ dict(bounds=[&quot;sat&quot;, &quot;sun&quot;]), # 隐藏周六、周日, 也可以不写, 非交易日列表中包含周末 dict(values=date_broken) # 隐藏列表中的日期 ] ) 非交易日获取方法获取非交易日日期列表. 交易日历使用QUANTAXIS获取. 123456789101112def get_date_broken(start, end): &quot;&quot;&quot;获取时段内非交易日&quot;&quot;&quot; start = start[:10] end = end[:10] # 区间能所有日期 date_all = [datetime.strftime(x, &#x27;%Y-%m-%d&#x27;) for x in list(pd.date_range(start=start, end=end))] # 交易日 date_trade = QA.QA_util_get_trade_range(start, end) # 非交易日 = 所有日期 - 交易日 date_broken = list(set(date_all).difference(set(date_trade))) date_broken.sort() # 上面操作后日期顺序会使乱的, 所以排序 return date_broken 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import pandas as pdimport plotly.graph_objects as gofrom plotly.subplots import make_subplotsfrom datetime import datetimeimport QUANTAXIS as QAdef get_date_broken(start, end): &quot;&quot;&quot;获取时段内非交易日&quot;&quot;&quot; start = start[:10] end = end[:10] # 区间能所有日期 date_all = [datetime.strftime(x, &#x27;%Y-%m-%d&#x27;) for x in list(pd.date_range(start=start, end=end))] # 交易日 date_trade = QA.QA_util_get_trade_range(start, end) # 非交易日 = 所有日期 - 交易日 date_broken = list(set(date_all).difference(set(date_trade))) date_broken.sort() # 上面操作后日期顺序会使乱的, 所以排序 return date_broken# 数据df = pd.read_csv(&#x27;https://raw.githubusercontent.com/xiongyifan/QUANTAXIS-Study/master/data/600132-2020.csv&#x27;)# df[&#x27;date&#x27;] = df[&#x27;date&#x27;].apply(lambda x: x.replace(&#x27;-&#x27;, &#x27;/&#x27;))df = df[:100]# 创建子图fig = make_subplots(rows=2, cols=1, shared_xaxes=True, subplot_titles=(&#x27;重庆啤酒&#x27;, &#x27;成交量&#x27;), row_width=[0.2, 0.7], vertical_spacing=0.05)# k线fig.add_trace(go.Candlestick(x=df[&quot;date&quot;], open=df[&quot;open&quot;], high=df[&quot;high&quot;], low=df[&quot;low&quot;], close=df[&quot;close&quot;], name=&quot;重庆啤酒&quot;), row=1, col=1)# 成交量fig.add_trace(go.Bar(x=df[&#x27;date&#x27;], y=df[&#x27;volume&#x27;], showlegend=False), row=2, col=1)# 不显示区间条fig.update(layout_xaxis_rangeslider_visible=False)# 获取非交易日期列表date_broken = get_date_broken(&#x27;2020-01-01&#x27;, &#x27;2020-12-31&#x27;)# 过滤非交易时间fig.update_xaxes( rangebreaks=[ dict(bounds=[&quot;sat&quot;, &quot;sun&quot;]), # 隐藏周六、周日 dict(values=date_broken) # 隐藏列表中的日期 ])fig.show() 相关文章Plotly-k线蜡烛图添加成交量Plotly-k线图多行多列","categories":[{"name":"Plotly","slug":"Plotly","permalink":"https://xiaofan.art/categories/Plotly/"}],"tags":[{"name":"Plotly","slug":"Plotly","permalink":"https://xiaofan.art/tags/Plotly/"}]},{"title":"Plotly-k线蜡烛图添加成交量","slug":"knowledge/投资/量化投资/编程/Plotly/Plotly-k线蜡烛图添加成交量","date":"2022-05-29T13:49:39.000Z","updated":"2022-05-31T08:55:00.000Z","comments":true,"path":"knowledge/94e9e8d90c3d149f/","link":"","permalink":"https://xiaofan.art/knowledge/94e9e8d90c3d149f/","excerpt":"","text":"效果图 完整代码1234567891011121314151617181920212223242526272829303132333435import pandas as pd import plotly.graph_objects as go from plotly.subplots import make_subplots # data df = pd.read_csv(&#x27;https://raw.githubusercontent.com/plotly/datasets/master/finance-charts-apple.csv&#x27;) # Create subplots and mention plot grid size # rows: 行数 # cols: 列数 # shared_xaxes: k线和成交量共享x轴 # vertical_spacing: k线和成交量上下间隔 # subplot_titles: 子图标题 # row_width: 这是一个向前兼容的参数, 方向是从下往上, 0.2对应的成交量的高度, 0.7对应的k线 # row_heights: row_width的替代参数, 默认方向是从上到下, 如果这里使用的话, 应该设为[0.7, 0.2] fig = make_subplots(rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.03, subplot_titles=(&#x27;OHLC&#x27;, &#x27;Volume&#x27;), row_width=[0.2, 0.7], # row_heights=[0.7, 0.2] ) # Plot OHLC on 1st row fig.add_trace(go.Candlestick(x=df[&quot;Date&quot;], open=df[&quot;AAPL.Open&quot;], high=df[&quot;AAPL.High&quot;], low=df[&quot;AAPL.Low&quot;], close=df[&quot;AAPL.Close&quot;], name=&quot;OHLC&quot;), row=1, col=1 ) # Bar trace for volumes on 2nd row without legend # showlegend: 是否显示右侧图标, 成交量不需要显示了, 有k线就够了 fig.add_trace(go.Bar(x=df[&#x27;Date&#x27;], y=df[&#x27;AAPL.Volume&#x27;], showlegend=False), row=2, col=1) # Do not show OHLC&#x27;s rangeslider plot # layout_xaxis_rangeslider_visible: k线的缩量图 fig.update(layout_xaxis_rangeslider_visible=False) fig.show() 基本逻辑Plotly有两个核心概念，分别是轨迹(trace)和画布(Figure)。下面导入的 plotly.graph_objects 专门用来绘制图表, 比如 go.Candlestick 蜡烛图，在 plotly 中，图表被称为轨迹（trace）。 在本例中, 通过make_subplots创建画布, 再创建k线轨迹和成交量轨迹添加到画布中, 最后展示出来. 调整k线图和成交量显示比例的方法方法1: row_width按照给定的比例分配整个画布的纵向空间 不指定row_width: 指定row_width: 可以看出k线图和成交量是显示比例上发生了变化, k线图占据了更多的空间. 方法2: spec指定底部内边距(bottom padding), 使成交量的内边距加大, 看起来成交量就窄了, 同时使下部有很大的留白, 对于多行多列图很有用. Plotly-k线图多行多列中使用的就是这种方法. 12345fig = make_subplots(rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.03, subplot_titles=(&#x27;OHLC&#x27;, &#x27;Volume&#x27;), # row_width=[0.2, 0.7], specs=[[&#123;&#125;], [&#123;&#x27;b&#x27;: 0.3&#125;]] ) 参考Plotly：如何向烛台图表添加交易量？ | (1r1g.com) 相关文章Plotly-k线图过滤非交易时间Plotly-k线图多行多列","categories":[{"name":"Plotly","slug":"Plotly","permalink":"https://xiaofan.art/categories/Plotly/"}],"tags":[{"name":"Plotly","slug":"Plotly","permalink":"https://xiaofan.art/tags/Plotly/"}]},{"title":"Python自动间隔拍照记录电脑前的你, 请保持欢笑","slug":"knowledge/Python自动间隔拍照记录电脑前的你, 请保持欢笑","date":"2022-05-27T08:53:35.000Z","updated":"2022-05-27T08:53:35.000Z","comments":true,"path":"knowledge/bd67a62b0c68ceca/","link":"","permalink":"https://xiaofan.art/knowledge/bd67a62b0c68ceca/","excerpt":"","text":"间隔1分, 自动拍照, 并保存在本地. 请撸代码时, 保持微笑. 测试环境: macOS 11.6 Python3.8.5 笔记本自带摄像头 首先安装opencv 1pip3 install opencv-python 在终端运行下面的代码, 系统提示需要摄像头权限, 允许后再次运行代码. 注: 需要在终端运行, 在PyCharm中无法正常运行, 原因未知. 123456789101112131415161718import cv2 import time while 1: cap = cv2.VideoCapture(0) i = 0 while 1: ret, frame = cap.read() if i == 100: # 刚刚启动摄像头的时候拍出来会很暗, 所以这里循环100次后再记录 name = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()) cv2.imwrite(&#x27;/Users/marco/Downloads/&#x27; + name + &#x27;.jpg&#x27;, frame) break else: i += 1 # cv2.imshow(&quot;capture&quot;, frame) # 显示摄像头拍摄的画面 cap.release() cv2.destroyAllWindows() time.sleep(60) 参考Mac 下使用python调用电脑摄像头_zhang__8626的博客-CSDN博客","categories":[{"name":"Python","slug":"Python","permalink":"https://xiaofan.art/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://xiaofan.art/tags/Python/"}]},{"title":"安装Visual Studio环境","slug":"knowledge/编程/操作系统/Windows/安装Visual Studio环境","date":"2021-12-25T07:26:17.000Z","updated":"2021-12-25T07:26:17.000Z","comments":true,"path":"knowledge/5cad19038ec382ca/","link":"","permalink":"https://xiaofan.art/knowledge/5cad19038ec382ca/","excerpt":"","text":"下载安装文件下载Visual Studio Tools - 免费安装Windows、Mac、Linux 安装运行安装文件，选择C++桌面开发，点击安装 修改安装在开始菜单中找到Visual Studio Installer可以卸载之前的安装，或者安装新的组件。","categories":[{"name":"Windows","slug":"Windows","permalink":"https://xiaofan.art/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://xiaofan.art/tags/Windows/"}]},{"title":"VNPY系列1-安装","slug":"knowledge/投资/量化投资/编程/框架/VNPY/自总结/VNPY系列1-安装","date":"2021-12-25T07:25:43.000Z","updated":"2021-12-25T07:25:43.000Z","comments":true,"path":"knowledge/5b015c01914e0dcb/","link":"","permalink":"https://xiaofan.art/knowledge/5b015c01914e0dcb/","excerpt":"","text":"下载在vnpy官网下载安装文件 下载完成后，得到vnstudio-x.x.x.exe 安装文件说明上面下载的exe安装文件是安装Python发行版VNStudio，里面包含两个部分： vn.py框架，编写策略就是基于这个框架 VN Station量化管理平台，图形界面方便使用vnpy框架 安装环境说明首先，一定要明确，我们是来做量化策略的，不是来折腾量化环境的，策略能帮你赚钱，环境不能，除非环境限制了你的策略。 所以建议直接使用上面下载的exe安装文件，在Windows 10 / Windows Server 2019 上安装原因： 官方提供安装包，并长期维护，一键安装，省时省力 出现问题，比较容易搜索到解决方案 不建议使用Windows 7 / Mac / Ubuntu安装或尝试安装原因： 官方不提供安装包，需要自己手动安装 安装过程遇到问题需要自己解决，网上的资料可能由于版本和系统环境不一致，不一定能解决你的问题 不建议使用Windows 11安装原因： 系统运行速度和各个软件的兼容性不及Windows 10 安装云服务器安装如果想做国内期货量化，云服务器可以不着急买。国内期货量化一般使用CTP接口，申请CTP账号时云服务器和虚拟机可能无法通过。具体原因参考看完这篇，彻底搞定期货穿透式CTP API接入常见问题中的能否使用云服务器或者虚拟机进行测试认证？我在国信期货申请CTP，云服务器获取不到参数，最后换成实体机才申请到CTP账号。 配置：双核4G内存即可系统：Windows Server 2019安装步骤：参照Windows10，两者一致 Mac安装Mac用户建议使用Parallels Desktop安装Windows 10虚拟机，不建议在虚拟机上安装Windows Server 2019，因为图形界面的显示效果远不及Windows 10。 安装步骤：安装完虚拟机Windows 10后，参照Windows 10安装步骤 Windows 10安装直接运行上面下载的exe安装文件，一路下一步，如果没有报错，就装完了。 如果出现报错，请不要犹豫直接安装Visual Studio环境，这可能能节省几个小时的时间，一把头发，以及后续版本也不会出现类似的问题，需要付出的是硬盘10个G的空间。 例如下面这个错误安装Visual Studio后，就不会报错了。官方也很快给出了错误原因和修复版本。","categories":[{"name":"VNPY","slug":"VNPY","permalink":"https://xiaofan.art/categories/VNPY/"}],"tags":[{"name":"VNPY","slug":"VNPY","permalink":"https://xiaofan.art/tags/VNPY/"}]},{"title":"QUANTAXIS-QAPUBSUB消息订阅组件","slug":"knowledge/投资/量化投资/编程/框架/QUANTAXIS/QUANTAXIS-QAPUBSUB消息订阅组件","date":"2021-11-16T10:16:07.000Z","updated":"2021-11-16T13:46:54.000Z","comments":true,"path":"knowledge/9415a00b301cc96e/","link":"","permalink":"https://xiaofan.art/knowledge/9415a00b301cc96e/","excerpt":"QAPUBSUB的作用QAPUBSUB是一种数据分发的方式，SUB订阅数据，PUB推送数据，EventMQ作为中间媒介。下面对比原始的For循环，和QAPUBSUB订阅模式的区别。 原始模式: 通过for循环遍历数据，一条条处理。订阅模式: 订阅数据后，名为on_bar的回调函数就等数据过来，过来一条处理一条。","text":"QAPUBSUB的作用QAPUBSUB是一种数据分发的方式，SUB订阅数据，PUB推送数据，EventMQ作为中间媒介。下面对比原始的For循环，和QAPUBSUB订阅模式的区别。 原始模式: 通过for循环遍历数据，一条条处理。订阅模式: 订阅数据后，名为on_bar的回调函数就等数据过来，过来一条处理一条。 原始模式12345import QUANTAXIS as QAdf = QA.QA_fetch_get_future_day(&#x27;tdx&#x27;, &#x27;RBL8&#x27;, &#x27;2019-09-01&#x27;, &#x27;2019-09-30&#x27;)for idx, data in df.iterrows(): print(&#x27;on_data: &#x27;, data) # 策略代码。。。 优点： 逻辑清晰 单个策略执行速度快 缺点在多个策略同时运行时暴露： API访问次数限制 同时访问数据库压力大 订阅模式 以中间的eventmq为媒介，生产者发布数据，消费者订阅接收数据。生产者发布一次，多个消费者接收数据，执行各自的逻辑。消费者加工数据后可以发布数据，供其他消费者使用，例如：图中消费者tick2Bar把tick数据变成bar数据后发布，策略订阅了bar数据，bar数据一来策略就运行起来了。 优点在多个策略同时运行时尤为明显： 多策略，数据持久化，发单等等写起来都很方便，只要订阅就好 缺点在多个策略同时运行时暴露： 逻辑上需要理解下 单策略执行速度不如for循环，毕竟有eventmq的开销 总的来说优点远大于缺点，用过的都说好。 命令行订阅发布1234567# 进入qaweb容器，也可进入其他容器，大部分容器都安装了qapubsub，mgdb和eventmq除外docker exec -it qaweb bash# 订阅qaps_sub --exchange x1 --model fanout --host qaeventmq# 发布，新开一个命令行执行qaps_pub --exchange x1 --model fanout --content 111 --host qaeventmq# 发布后，订阅的命令行就会收到数据 Python代码12345678910111213141516171819# 订阅from QAPUBSUB.consumer import subscriber, subscriber_routing# 订阅名为x1的exchangesub = subscriber(exchange=&#x27;x1&#x27;)# 修改回调函数def on_data(a, b, c, data): print(&#x27;on_data: &#x27;, data) # 策略代码。。。sub.callback = on_data# 开启订阅# 1. 线程阻塞，需要订阅和发布在两个线程中执行# sub.start() # 2. 线程不阻塞import threadingthreading.Thread(target=sub.start).start() 1234# 发布from QAPUBSUB.producer import publisher, publisher_routingpub = publisher(exchange=&#x27;x1&#x27;)pub.pub(&#x27;111&#x27;) # pub后上面的订阅就会收到 12345# 从QA获取数据然后pub，上面sub就会收到数据import QUANTAXIS as QAdf = QA.QA_fetch_get_future_day(&#x27;tdx&#x27;, &#x27;RBL8&#x27;, &#x27;2019-09-01&#x27;, &#x27;2019-09-30&#x27;)for idx, item in df.iterrows(): pub.pub(item.to_json()) GitHubhttps://github.com/yutiansut/QAPUBSUB","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/tags/QUANTAXIS/"}]},{"title":"Docker安装","slug":"knowledge/编程/容器/Docker/Docker安装","date":"2021-11-13T17:52:11.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/e4809e342a40dd55/","link":"","permalink":"https://xiaofan.art/knowledge/e4809e342a40dd55/","excerpt":"Ubuntu安装脚本wget下载脚本安装，脚本中包括安装docker，开启非root用户执行docker命令，修改docker源（腾讯）。 1curl -sSL https://gitee.com/xiongyifan/quantaxis-study/raw/master/bash/install_docker.sh | sh","text":"Ubuntu安装脚本wget下载脚本安装，脚本中包括安装docker，开启非root用户执行docker命令，修改docker源（腾讯）。 1curl -sSL https://gitee.com/xiongyifan/quantaxis-study/raw/master/bash/install_docker.sh | sh Window安装系统选择Win10专业版或者企业版：这两个版本有hyper-v功能，可以安装docker-ceWin10家庭版或ghost：家庭版没有hyper-v功能，ghost版本可能阉割了hyper-v，所以装不了docker-ceWin7：只能安装docker toolbox，本质是虚拟机，依赖多，而且从github上下载很慢。 安装过程中的问题安装过程中要选择linux container，而不是window container。否则会遇到docker-compose版本过旧的问题。","categories":[{"name":"Docker","slug":"Docker","permalink":"https://xiaofan.art/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xiaofan.art/tags/Docker/"}]},{"title":"QUANTAXIS脚本安装","slug":"knowledge/投资/量化投资/编程/框架/QUANTAXIS/QUANTAXIS脚本安装","date":"2021-11-13T17:52:09.000Z","updated":"2022-02-21T11:51:42.000Z","comments":true,"path":"knowledge/ebdfa7c933851e11/","link":"","permalink":"https://xiaofan.art/knowledge/ebdfa7c933851e11/","excerpt":"Docker安装Docker安装 QUANTAXIS安装脚本根据天神的qa-service-pro修改，但只保留了7个基本的容器，qa，qaweb，mgdb，qaeventmq，qactpbeebroker，qamarketcollector，qatrader，后面需要时再增加。 1234567891011# 1. 创建QA文件夹，用于存放安装相关的文件mkdir QA cd QA# 2. 在群文件中下载quantaxis-1.10.19xxx.whl和pytdx-1.72xxx.whl，因为群文件会更新，所以这里用xxx代替。# 群文件的版本修复了一些已知的报错。# 下载好后放在QA目录下# 3. 执行安装脚本# 如果QA目录下有docker-compose.yaml请做好备份，因为脚本会下载一个配套的docker-compose.yaml# 默认会覆盖掉原有的docker-compose.yamlcurl -sSL https://gitee.com/xiongyifan/quantaxis-study/raw/master/bash/install_qa.sh | sh# 等待安装完成即可","text":"Docker安装Docker安装 QUANTAXIS安装脚本根据天神的qa-service-pro修改，但只保留了7个基本的容器，qa，qaweb，mgdb，qaeventmq，qactpbeebroker，qamarketcollector，qatrader，后面需要时再增加。 1234567891011# 1. 创建QA文件夹，用于存放安装相关的文件mkdir QA cd QA# 2. 在群文件中下载quantaxis-1.10.19xxx.whl和pytdx-1.72xxx.whl，因为群文件会更新，所以这里用xxx代替。# 群文件的版本修复了一些已知的报错。# 下载好后放在QA目录下# 3. 执行安装脚本# 如果QA目录下有docker-compose.yaml请做好备份，因为脚本会下载一个配套的docker-compose.yaml# 默认会覆盖掉原有的docker-compose.yamlcurl -sSL https://gitee.com/xiongyifan/quantaxis-study/raw/master/bash/install_qa.sh | sh# 等待安装完成即可 QUANTAXIS初始化以下内容复制自QQ群公告第一次部署docker版QA必须的初始化操作步骤： 在浏览器输入docker宿主机”ip地址:8888”； 进入jupyterlab登录界面后输入口令”quantaxis”; 进入jupyterlab启动页，点击Terminal进入终端； 在终端界面输入”/bin/bash”,进入bash状态； bash状态输入”quantaxis”,进入数据库操作状态； 依次输入完成数据库初始化12save stock_listsave single_index_day 000300 输入exit退出终端 在docker管理界面重启qaweb容器 浏览器输入docker宿主机”ip地址:81”，弹出的登录界面把登录地址端口改为docker宿主机”ip地址:8010”，点击登录进入QA前端界面 脚本内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#!/bin/sh# 安装QA# 1. 下载docker-compose.yaml文件# wget https://gitee.com/xiongyifan/quantaxis-study/raw/master/docker/docker-compose.yaml # 不会覆盖已有文件wget https://gitee.com/xiongyifan/quantaxis-study/raw/master/docker/docker-compose.yaml -O docker-compose.yaml # 会覆盖已有文件# 2. 创建数据卷sudo docker volume create --name=qamgsudo docker volume create --name=qacodesudo docker volume create --name=pg-datasudo docker volume create --name=qadagsudo docker volume create --name=qaconfsudo docker volume create --name=qausersudo docker volume create --name=qalog# 3. 下载并创建docker容器sudo docker-compose up -d# 4. 安装群文件中的pytdx，quantaxis# 4.1 获取pytdx，quantaxis的文件名fileNames=$(ls)quantaxisFileName=&#x27;&#x27;pytdxFileName=&#x27;&#x27;for fileName in $fileNamesdo if [ `echo $fileName | grep -c &quot;pytdx&quot;` -ne &#x27;0&#x27; ]; then pytdxFileName=$fileName fi if [ `echo $fileName | grep -c &quot;quantaxis&quot;` -ne &#x27;0&#x27; ]; then quantaxisFileName=$fileName fidone# 4.2 安装函数installNewPytdxQA()&#123; # findStr，当容器日志中出现指定字符串时说明容器启动完成了，这个时候可以开始安装群文件中的qa和pytdx版本。 # 这么做的原因是容器自己也会安装qa和pytdx，要等它先装完，然后你再卸载安装，否则你装的会被容器安装的覆盖掉。 findStr=$1 # containerName, 容器名，这个容器名在docker-compose.yaml中container_name中指定 containerName=$2 # isInstallQA，是否安装群文件中的qa。qamarketcollector容器可以不安装群中qa版本，因为不影响使用。 isInstallQA=$3 echo &quot;在&quot; $&#123;containerName&#125; &quot;中重新安装&quot; $&#123;pytdxFileName&#125; &quot;和&quot; $&#123;quantaxisFileName&#125; # 找到容器对应的日志文件 findFile=$(sudo docker inspect --format=&#x27;&#123;&#123;.LogPath&#125;&#125;&#x27; $&#123;containerName&#125;) echo $&#123;containerName&#125; &quot;容器的日志位置：&quot; $&#123;findFile&#125; # 在日志文件中不断的查到findStr，找到后说明容器已经初始化完成，可以开始安装qa和pytdx。 while : do # 判断匹配函数，匹配函数不为0，则包含给定字符 if [ `sudo grep -c &quot;$&#123;findStr&#125;&quot; $&#123;findFile&#125;` -ne &#x27;0&#x27; ];then # 安装pytdx sudo docker cp ./$&#123;pytdxFileName&#125; $&#123;containerName&#125;:/root sudo docker exec $&#123;containerName&#125; pip uninstall pytdx -y sudo docker exec $&#123;containerName&#125; pip install /root/$&#123;pytdxFileName&#125; # 安装qa if [ $&#123;isInstallQA&#125; = &quot;true&quot; ];then sudo docker cp ./$&#123;quantaxisFileName&#125; $&#123;containerName&#125;:/root sudo docker exec $&#123;containerName&#125; pip uninstall quantaxis -y sudo docker exec $&#123;containerName&#125; pip install /root/$&#123;quantaxisFileName&#125; fi break fi sleep 1s done&#125;# 4.3 安装# 以，使用control-c停止此服务器，作用findStr，是根据容器首次启动的日志提取出来的，# 当日志不再打印时，说明容器首次启动完成，在日志末尾找一段文本，测试能够在卸载后重新安装即可。installNewPytdxQA &quot;使用control-c停止此服务器&quot; &quot;qacommunity-rust&quot; &quot;true&quot;# mingle: all alone，同理installNewPytdxQA &quot;mingle: all alone&quot; &quot;qaweb&quot; &quot;true&quot;installNewPytdxQA &quot;if you use ssh&quot; &quot;qamarketcollector&quot; &quot;false&quot;# Step 5: 重启容器sudo docker-compose restart# Step 6: 手动初始化","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS-QARealtimeCollector行情订阅和二次采样组件","slug":"knowledge/投资/量化投资/编程/框架/QUANTAXIS/QUANTAXIS-QARealtimeCollector行情订阅和二次采样组件","date":"2021-11-13T17:52:08.000Z","updated":"2021-11-16T15:27:29.000Z","comments":true,"path":"knowledge/e5b8132e67d4490d/","link":"","permalink":"https://xiaofan.art/knowledge/e5b8132e67d4490d/","excerpt":"QARealtimeCollector的作用QARealtimeCollector的作用有两个： 对实时tick数据进行二次采样，包括股票和期货。由QARC_WEBSERVER命令提供。 股票实时tick行情接入。由QARC_Stock提供，通过pytdx接入股票tick行情。 123# 命令行启动服务QARC_WEBSERVER # 提供http服务，进行股票和期货的订阅和二次采样QARC_Stock # 提供股票的tick行情","text":"QARealtimeCollector的作用QARealtimeCollector的作用有两个： 对实时tick数据进行二次采样，包括股票和期货。由QARC_WEBSERVER命令提供。 股票实时tick行情接入。由QARC_Stock提供，通过pytdx接入股票tick行情。 123# 命令行启动服务QARC_WEBSERVER # 提供http服务，进行股票和期货的订阅和二次采样QARC_Stock # 提供股票的tick行情 QARealtimeCollector安装步骤增加QARealtimeCollector模块在docker-compose.yaml中添加qamarketcollector模块 12345678910111213141516qamarketcollector: image: daocloud.io/quantaxis/qarealtimecollector:latest container_name: qamarketcollector ports: - &quot;8011:8011&quot; depends_on: - mgdb - qaeventmq environment: - MONGODB=mgdb - EventMQ_IP=qaeventmq networks: qanetwork_pro: ipv4_address: 172.19.3.8 command: [&#x27;/root/QUANTAXIS_RealtimeCollector/docker/wait_for_it.sh&#x27;, &#x27;qaeventmq:5672&#x27;, &#x27;--&#x27; ,&#x27;/root/QUANTAXIS_RealtimeCollector/docker/start_collector.sh&#x27;] command中指定的start_collector.sh脚本会执行QARC_WEBSERVER和QARC_Stock命令 启动如果是新添加的qamarketcollector，那么可以直接通过下面的命令启动。 1docker-compose up -d 如果之前已经跟其他模块一起启动的话，qamarketcollector模块会正常启动。 订阅分钟行情订阅地址：POST http://10.211.55.38:8011?action=new_handler&amp;market_type=future_cn&amp;code=rb2201 订阅成功后CTPX里面会增加一个rb2201，Exchange会增加realtime_min_rb2201和bar_1min_rb2201，然后命令行订阅就可以看到数据 12qaps_sub --exchange realtime_min_rb2201 --model fanoutqaps_sub --exchange bar_1min_rb2201 --model fanout 上面是realtime_min_rb2201的数据，下面是bar_1min_rb2201的数据。 二次采样x分钟数据POST http://10.211.55.38:8011?action=new_resampler&amp;market_type=future_cn&amp;code=rb2201&amp;frequence=5min 订阅成功后Exchange会增加一个realtime_5min_rb2201 1qaps_sub --exchange realtime_5min_rb2201 --model fanout 订阅股票tick数据POST http://10.211.55.38:8011?action=new_handler&amp;market_type=stock_cn&amp;code=000001 订阅成功后通过名为stocktransaction的exchange获取数据 1qaps_sub --exchange stocktransaction --model fanout http请求合集123456789101112# 订阅股票POST http://10.211.55.40:8011?action=new_handler&amp;market_type=stock_cn&amp;code=000001# 订阅期货POST http://10.211.55.40:8011?action=new_handler&amp;market_type=future_cn&amp;code=rb2201# 股票采样POST http://10.211.55.40:8011?action=new_resampler&amp;market_type=stock_cn&amp;code=000001&amp;frequence=5min# 期货采样POST http://10.211.55.40:8011?action=new_resampler&amp;market_type=future_cn&amp;code=rb2201&amp;frequence=5min# 现在的订阅POST http://10.211.55.40:8011?action=get_current_handler# 现在的采样POST http://10.211.55.40:8011?action=get_current_resampler GithubQUANTAXIS_RealtimeCollector 问题realtime_5min_rb2201的数据有，但是tradetime是错的，”tradetime”: “wrong date 22:36:30”，什么都没动，第二天的数据就正常了 股票数据出不来，原因是因为数据是从pytdx过来的，docker里的pytdx有问题，安装QQ群里的就好了","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS-QACTPBeeBroker实时行情组件","slug":"knowledge/投资/量化投资/编程/框架/QUANTAXIS/QUANTAXIS-QACTPBeeBroker实时行情组件","date":"2021-11-13T17:52:06.000Z","updated":"2021-11-16T15:27:34.000Z","comments":true,"path":"knowledge/50efbeb4d7a55858/","link":"","permalink":"https://xiaofan.art/knowledge/50efbeb4d7a55858/","excerpt":"QACTPBeeBroker的作用QACTPBeeBroker的作用是获取期货实时的tick行情。行情会被PUB到名为CTPX的Exchange中。 QACTPBeeBroker接入实时行情的步骤1. 增加qactpbeebroker模块在docker-compose.yaml中添加qactpbeebroker模块 1234567891011121314151617181920 qactpbeebroker: image: daocloud.io/quantaxis/qactpbeebroker:latest container_name: qactpbeebroker ports: - &quot;5000:5000&quot; networks: qanetwork_pro: ipv4_address: 172.19.3.7 # --userid TEXT # --password TEXT # --brokerid TEXT # --mdaddr TEXT # --tdaddr TEXT # --appid TEXT # --authcode TEXT# 默认从simnow获取行情，账号是天神给定的simnow账号，可替换成自己的账号# 即使注释掉command，QACTPBEE还是会连接天神给定的simnow账号，原因不明。 command: [&#x27;/root/wait_for_it.sh&#x27;, &#x27;qaeventmq:15672&#x27;, &#x27;--&#x27; , &quot;QACTPBEE&quot;, &quot;--userid&quot;, &quot;133496&quot;, &quot;--password&quot;, &#x27;QCHL1234&#x27;]","text":"QACTPBeeBroker的作用QACTPBeeBroker的作用是获取期货实时的tick行情。行情会被PUB到名为CTPX的Exchange中。 QACTPBeeBroker接入实时行情的步骤1. 增加qactpbeebroker模块在docker-compose.yaml中添加qactpbeebroker模块 1234567891011121314151617181920 qactpbeebroker: image: daocloud.io/quantaxis/qactpbeebroker:latest container_name: qactpbeebroker ports: - &quot;5000:5000&quot; networks: qanetwork_pro: ipv4_address: 172.19.3.7 # --userid TEXT # --password TEXT # --brokerid TEXT # --mdaddr TEXT # --tdaddr TEXT # --appid TEXT # --authcode TEXT# 默认从simnow获取行情，账号是天神给定的simnow账号，可替换成自己的账号# 即使注释掉command，QACTPBEE还是会连接天神给定的simnow账号，原因不明。 command: [&#x27;/root/wait_for_it.sh&#x27;, &#x27;qaeventmq:15672&#x27;, &#x27;--&#x27; , &quot;QACTPBEE&quot;, &quot;--userid&quot;, &quot;133496&quot;, &quot;--password&quot;, &#x27;QCHL1234&#x27;] 2. 启动如果是新添加的qactpbeebroker，那么可以直接通过下面的命令启动。 1docker-compose up -d 如果之前已经跟其他模块一起启动的话，qactpbeebroker可能会启动失败，原因不明。解决办法，手动重新启动下就好了。 12docker ps # 没有qactpbeebroker的话，说明已经停止运行了docker-compose start qactpbeebroker # 运行命令启动 3. 检查1docker logs --tail 10000 -f qactpbeebroker 如果日志显示连接成功，或者有在打印合约代码，说明接入成功了。 接入成功后，15672页面会增加名为CTPX的Exchange。但是由于Exchange失效后不会自动在15672页面消失，所以有CTPX不意味着连接成功，看日志更保险。 订阅tick行情订阅tick行情，大概每秒2条tick行情。如果是simnow行情，经常会中断，或延迟。 1qaps_sub --exchange CTPX --model direct --routing_key rb2201 订阅成功后，命令行显示tick行情 并且名为CTPX的Exchange增加 CTPBEE的任务是连接实盘tick行情，分钟行情则需要使用QARealtimeCollector二次采样分发。 问题docker-compose up -d所有容器全部一起启动，qactpbeebroker会死掉，手动再启动就好了，不知道怎么回事 10:15~10:30 rb2201数据停了，是因为这15分钟不是交易时间 Githubhttps://github.com/ctpbee/ctpbeehttps://github.com/yutiansut/QACTPBeeBroker","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS实时数据模拟撮合","slug":"knowledge/投资/量化投资/编程/框架/QUANTAXIS/安装到实盘/QUANTAXIS实时数据模拟撮合","date":"2021-11-13T17:52:05.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/6e8f7a03cfbd89f6/","link":"","permalink":"https://xiaofan.art/knowledge/6e8f7a03cfbd89f6/","excerpt":"整个流程与QUANTAXIS实时数据本地撮合有两点不同： 模拟撮合通过qatrader模块连接模拟盘账户完成订单。 账户查询操作通过数据库完成，而不是QAAccount 模拟账户接入QUANTAXIS-QATrader模拟和实盘交易组件 接入成功后，通过pub发单即可。","text":"整个流程与QUANTAXIS实时数据本地撮合有两点不同： 模拟撮合通过qatrader模块连接模拟盘账户完成订单。 账户查询操作通过数据库完成，而不是QAAccount 模拟账户接入QUANTAXIS-QATrader模拟和实盘交易组件 接入成功后，通过pub发单即可。 账户准备账户查询操作通过数据库完成，而不是QAAccountaccount_cookie是qatader命令指定的–accqatader执行成功后就可以在数据库查询到账户信息。 123456# 1. 账户准备account_cookie = &#x27;101010&#x27;db = pymongo.MongoClient(os.getenv(&#x27;MONGODB&#x27;)).QAREALTIMEdef find_acc(): return db.account.find_one(&#123;&#x27;account_cookie&#x27;: account_cookie&#125;)simacc = find_acc() 发单操作方法模拟账户通过pub到名为QAORDER_ROUTER的Exchange完成发单，而不是调用simple_deal。 为简化流程sendorder发单价格要高些，不然会出现多次买多等情况。 123456789101112131415pub = publisher_routing(exchange=&#x27;QAORDER_ROUTER&#x27;)def sendorder(code, price, order_direction, order_offset, volume): routing_key = account_cookie pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: account_cookie, &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: code, &#x27;price&#x27;: price, &#x27;order_direction&#x27;: order_direction, &#x27;order_offset&#x27;: order_offset, &#x27;volume&#x27;: volume, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;, &#125;), routing_key=routing_key) 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import QUANTAXIS as QAfrom QAPUBSUB.consumer import subscriberfrom QAPUBSUB.producer import publisher, publisher_routingimport threading, json, pymongo, os, datetimeimport pandas as pd# 1. 账户准备account_cookie = &#x27;marco07281&#x27;db = pymongo.MongoClient(os.getenv(&#x27;MONGODB&#x27;)).QAREALTIMEdef find_acc(): return db.account.find_one(&#123;&#x27;account_cookie&#x27;: account_cookie&#125;)simacc = find_acc()# 2. 发单操作方法BUY = &#x27;BUY&#x27;SELL = &#x27;SELL&#x27;OPEN = &#x27;OPEN&#x27;CLOSETODAY = &#x27;CLOSETODAY&#x27;pub = publisher_routing(exchange=&#x27;QAORDER_ROUTER&#x27;)def sendorder(code, price, order_direction, order_offset, volume): routing_key = account_cookie pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: account_cookie, &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: code, &#x27;price&#x27;: price, &#x27;order_direction&#x27;: order_direction, &#x27;order_offset&#x27;: order_offset, &#x27;volume&#x27;: volume, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;, &#125;), routing_key=routing_key)# 3. 策略market_data_list = []def on_data(a, b, c, data): # 数据准备 bar = json.loads(data) market_data_list.append(bar) market_data_df = pd.DataFrame(market_data_list).set_index(&#x27;datetime&#x27;, drop=False) # 计算指标 ind = QA.QA_indicator_MA(market_data_df, 2, 4) print(ind) # 策略逻辑 MA2 = ind.iloc[-1][&#x27;MA2&#x27;] MA4 = ind.iloc[-1][&#x27;MA4&#x27;] code = bar[&#x27;code&#x27;].lower() trade_price = bar[&#x27;close&#x27;] trade_amount = 1 trade_time = bar[&#x27;datetime&#x27;] simacc = find_acc() positions = simacc[&#x27;positions&#x27;] code_key = &#x27;SHFE_&#x27; + &#x27;rb2201&#x27; volume_long = positions[code_key][&#x27;volume_long&#x27;] if code_key in positions else 0 volume_short = positions[code_key][&#x27;volume_short&#x27;] if code_key in positions else 0 print(MA2, MA4, code, trade_price, trade_time, volume_long, volume_short) if MA2 &gt; MA4: # 先平空，否则会先执行买多，就会不会平空了 if volume_short &gt; 0: print(&#x27;平空&#x27;) sendorder(code, trade_price + 5, BUY, CLOSETODAY, trade_amount) if volume_long == 0: print(&#x27;买多&#x27;) sendorder(code, trade_price + 5, BUY, OPEN, trade_amount) elif volume_long &gt; 0: print(&#x27;持有&#x27;) elif MA4 &gt; MA2: if volume_long &gt; 0: print(&#x27;平多&#x27;) sendorder(code, trade_price - 5, SELL, CLOSETODAY, trade_amount) if volume_short == 0: print(&#x27;卖空&#x27;) sendorder(code, trade_price - 5, SELL, OPEN, trade_amount) elif volume_short &gt; 0: print(&#x27;持有&#x27;) else: print(&#x27;不操作&#x27;)# 3. 订阅数据sub = subscriber(exchange=&#x27;bar_1min_rb2201&#x27;)sub.callback=on_datathreading.Thread(target=sub.start).start()","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS实时数据本地撮合","slug":"knowledge/投资/量化投资/编程/框架/QUANTAXIS/安装到实盘/QUANTAXIS实时数据本地撮合","date":"2021-11-13T17:52:04.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/1b4999756a5fe616/","link":"","permalink":"https://xiaofan.art/knowledge/1b4999756a5fe616/","excerpt":"实时tick数据接入QUANTAXIS-QACTPBeeBroker实时行情组件 实时tick数据接入后，就可以进行二次采样 二次采样数据QUANTAXIS-QARealtimeCollector行情订阅和二次采样组件 订阅rb2201成功后，下面通过bar_1min_rb2201做策略","text":"实时tick数据接入QUANTAXIS-QACTPBeeBroker实时行情组件 实时tick数据接入后，就可以进行二次采样 二次采样数据QUANTAXIS-QARealtimeCollector行情订阅和二次采样组件 订阅rb2201成功后，下面通过bar_1min_rb2201做策略 创建用户账户的account_cookie改成了test_realtime_simpledeal，测试实时数据simpledeal撮合。 1acc = port.new_account(&#x27;test_realtime_simpledeal&#x27;, 100000, QA.MARKET_TYPE.FUTURE_CN) 策略set_index的date，改成了datetime，之前本地数据用的日线的date，现在是1分钟实时数据用的是datetime 1market_data_df = pd.DataFrame(market_data_list).set_index(&#x27;datetime&#x27;, drop=False) trade_time改成datetime，之前本地数据用的日线的date+’ 00:00:00’，现在1分钟实时数据直接用datetime 1trade_time = bar[&#x27;datetime&#x27;] 数据是实时推送的，不能在所有代码执行完毕后查看结果。所以在策略的最后保存了acc，可随时通过代码或数据库查看交易情况。 1acc.save() 订阅数据exchange改成了bar_1min_rb2201，之前的exchange是自己命名的，现在订阅的是实时1分钟的螺纹钢 1sub = subscriber(exchange=&#x27;bar_1min_rb2201&#x27;) 数据获取并推送数据这块代码不需要了。数据是CTPX主动推送的，所以只需要在上面订阅好需要数据就行。 查看和保存结果这两块也不需要了，数据是慢慢推过来的，想看阶段结果就用acc查看即可。 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import QUANTAXIS as QAfrom QAPUBSUB.consumer import subscriberfrom QAPUBSUB.producer import publisherimport threading, jsonimport pandas as pd# 1. 账户准备user = QA.QA_User(username=&#x27;admin&#x27;, password=&#x27;admin&#x27;)port = user.new_portfolio(&#x27;x1&#x27;)acc = port.new_account(&#x27;test_realtime_simpledeal&#x27;, 100000, QA.MARKET_TYPE.FUTURE_CN)# 2. 发单操作方法def sendorder(code, trade_price, trade_towards, trade_time): acc.receive_simpledeal( code=code, trade_price=trade_price, trade_amount=trade_amount, trade_towards=trade_towards, trade_time=trade_time)# 3. 策略market_data_list = []def on_data(a, b, c, data): # 数据准备 bar = json.loads(data) market_data_list.append(bar) market_data_df = pd.DataFrame(market_data_list).set_index(&#x27;datetime&#x27;, drop=False) # 计算指标 ind = QA.QA_indicator_MA(market_data_df, 2, 4) print(ind) # 策略逻辑 MA2 = ind.iloc[-1][&#x27;MA2&#x27;] MA4 = ind.iloc[-1][&#x27;MA4&#x27;] code = bar[&#x27;code&#x27;] trade_price = bar[&#x27;close&#x27;] trade_amount = 1 trade_time = bar[&#x27;datetime&#x27;] code_hold_available = acc.hold_available.get(code, 0) if MA2 &gt; MA4: if code_hold_available == 0: print(&#x27;买多&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.BUY_OPEN, trade_time) elif code_hold_available &gt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平空&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.BUY_CLOSE, trade_time) elif MA4 &gt; MA2: if code_hold_available == 0: print(&#x27;卖空&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.SELL_OPEN, trade_time) elif code_hold_available &lt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平多&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.SELL_CLOSE, trade_time) else: print(&#x27;不操作&#x27;) # 保存结果 acc.save() # 4. 订阅数据sub = subscriber(exchange=&#x27;bar_1min_rb2201&#x27;)sub.callback=on_datathreading.Thread(target=sub.start).start()","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS从安装到实盘","slug":"knowledge/投资/量化投资/编程/框架/QUANTAXIS/安装到实盘/QUANTAXIS从安装到实盘","date":"2021-11-13T17:52:03.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/c5bed9ec3b959bfd/","link":"","permalink":"https://xiaofan.art/knowledge/c5bed9ec3b959bfd/","excerpt":"","text":"内容整理自天神的视频，目前更新到STU02 系统环境：Ubuntu 20.04 QUANTAXIS脚本安装QUANTAXIS脚本安装 QUANTAXIS本地数据本地撮合QUANTAXIS本地数据本地撮合 QUANTAXIS实时数据本地撮合QUANTAXIS实时数据本地撮合 QUANTAXIS实时数据模拟撮合QUANTAXIS实时数据模拟撮合 QUANTAXIS实时数据实盘交易待完成","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS本地数据本地撮合","slug":"knowledge/投资/量化投资/编程/框架/QUANTAXIS/安装到实盘/QUANTAXIS本地数据本地撮合","date":"2021-11-13T17:52:02.000Z","updated":"2021-11-16T09:15:46.000Z","comments":true,"path":"knowledge/d1be47f9274e8671/","link":"","permalink":"https://xiaofan.art/knowledge/d1be47f9274e8671/","excerpt":"QUANTAXIS本地数据本地撮合，以及后面的模拟到实盘，都基于QAPUBSUB实现。 QAPUBSUBQUANTAXIS-QAPUBSUB消息订阅组件 数据准备1234# 打开8888页面，开启一个命令行，执行下面3个命令/bin/bashquantaxissave single_future_day RBL8","text":"QUANTAXIS本地数据本地撮合，以及后面的模拟到实盘，都基于QAPUBSUB实现。 QAPUBSUBQUANTAXIS-QAPUBSUB消息订阅组件 数据准备1234# 打开8888页面，开启一个命令行，执行下面3个命令/bin/bashquantaxissave single_future_day RBL8 import依赖123456import QUANTAXIS as QAfrom QAPUBSUB.consumer import subscriber # 消费者from QAPUBSUB.producer import publisher # 生产者import threading # 在线程中运行消费者，防止线程阻塞import json # 消费者接收的数据是文本，转成jsonimport pandas as pd # json转成DataFrame 账户准备用户(User) -&gt; 组合(Portfolio) -&gt; 账户(Account)一个用户下面可以有多个组合，一个组合下面可以有多个账户，实际交易的是账户。就像一个基金经理，操作多个投资组合，一个投资组合分多个策略，在不同的账户中执行。 123456# 1. 账户准备user = QA.QA_User(username=&#x27;admin&#x27;, password=&#x27;admin&#x27;) # 账号密码跟81页面登录的账号密码一致# portfolio_cookie就像是组合的idport = user.new_portfolio(portfolio_cookie=&#x27;x1&#x27;)# account_cookie就像是账户的id，init_cash是账户的初始资金，market_type为市场类型，QA中通过market_type预设了交易规则，例如期货允许t0等，与国内的交易规则一致。acc = port.new_account(account_cookie=&#x27;test_local_simpledeal&#x27;, init_cash=100000, market_type=QA.MARKET_TYPE.FUTURE_CN) 发单操作方法发单用的是QAAccount的receive_simpledeal方法，这个方法会直接完成撮合，一定成交。而模拟盘和实盘使用的是QATrader，根据实时行情撮合，不一定成交。 12345678# 2. 发单操作方法def sendorder(code, trade_price, trade_amount, trade_towards, trade_time): acc.receive_simpledeal( code=code, trade_price=trade_price, trade_amount=trade_amount, trade_towards=trade_towards, trade_time=trade_time) 策略MA2 &gt; MA4：买多，有多头仓平空MA4 &gt; MA2：卖空，有空头仓平多 123456789101112131415161718192021222324252627282930313233343536373839404142# 3. 策略market_data_list = [] # 存储历史数据# 下面订阅数据时会指定on_data为回调函数，接到数据就会执行on_datadef on_data(a, b, c, data): # 数据准备 bar = json.loads(data) market_data_list.append(bar) # 日线date格式是2019-01-01 market_data_df = pd.DataFrame(market_data_list).set_index(&#x27;date&#x27;, drop=False) # 计算指标 ind = QA.QA_indicator_MA(market_data_df, 2, 4) # 计算MA2和MA4 print(ind) # 策略逻辑 MA2 = ind.iloc[-1][&#x27;MA2&#x27;] # 取最新的MA2 MA4 = ind.iloc[-1][&#x27;MA4&#x27;] # 取最新的MA4 code = bar[&#x27;code&#x27;] # 合约代码 trade_price = bar[&#x27;close&#x27;] # 最新收盘价 trade_amount = 1 # 1手 trade_time = bar[&#x27;date&#x27;] + &#x27; 00:00:00&#x27; # 由于日线date的格式是2019-01-01，所以要加后面的时间，否则无法计算指标，后面的问题章节有详细说明。 code_hold_available = acc.hold_available.get(code, 0) # 合约目前的持仓情况 if MA2 &gt; MA4: if code_hold_available == 0: print(&#x27;买多&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.BUY_OPEN, trade_time) elif code_hold_available &gt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平空&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.BUY_CLOSE, trade_time) elif MA4 &gt; MA2: if code_hold_available == 0: print(&#x27;卖空&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.SELL_OPEN, trade_time) elif code_hold_available &lt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平多&#x27;) sendorder(code, trade_price, QA.ORDER_DIRECTION.SELL_CLOSE, trade_time) else: print(&#x27;不操作&#x27;) 订阅数据1234# 4. 订阅数据sub = subscriber(exchange=&#x27;x1&#x27;) # Exchange名为x1，在15672页面能看到sub.callback=on_data # 指定回调函数threading.Thread(target=sub.start).start() # 开线程执行订阅，防止线程阻塞，后面的发布代码无法执行 数据获取并推送数据1234567# 5. 数据获取并推送数据# 获取df = QA.QA_fetch_get_future_day(&#x27;tdx&#x27;, &#x27;RBL8&#x27;, &#x27;2019-08-01&#x27;, &#x27;2019-08-30&#x27;)# 推送pub = publisher(exchange=&#x27;x1&#x27;) # 跟订阅的Exchange一致for idx, item in df.iterrows(): pub.pub(item.to_json()) # 每行数据换成json，pub出去，上面的on_data就会收到，开始执行策略。 查看结果1234567# 6. 查看结果risk = QA.QA_Risk(acc)performance = QA.QA_Performance(acc)acc.history_table # 交易记录risk.plot_assets_curve() # 资产曲线performance.pnl # 盈利情况 保存结果12# 7. 保存结果risk.save() risk保存后，81页面查看回测结果。绩效分析结果没有。 1acc.save() 保存acc后，再看81页面，绩效分析就开始转圈，原因不明。 完整代码jupyter notebook 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/usr/bin/env python# coding: utf-8import QUANTAXIS as QAfrom QAPUBSUB.consumer import subscriber # 消费者from QAPUBSUB.producer import publisher # 生产者import threading # 在线程中运行消费者，防止线程阻塞import json # 消费者接收的数据是文本，转成jsonimport pandas as pd # json转成DataFrame# 1. 账户准备user = QA.QA_User(username=&#x27;admin&#x27;, password=&#x27;admin&#x27;) # 账号密码跟81页面登录的账号密码一致# portfolio_cookie就像是组合的idport = user.new_portfolio(portfolio_cookie=&#x27;x1&#x27;)# account_cookie就像是账户的id，init_cash是账户的初始资金，market_type为市场类型，QA中通过market_type预设了交易规则，例如期货允许t0等，与国内的交易规则一致。acc = port.new_account(account_cookie=&#x27;test_local_simpledeal&#x27;, init_cash=100000, market_type=QA.MARKET_TYPE.FUTURE_CN)# 2. 发单操作方法def sendorder(code, trade_price, trade_amount, trade_towards, trade_time): acc.receive_simpledeal( code=code, trade_price=trade_price, trade_amount=trade_amount, trade_towards=trade_towards, trade_time=trade_time)# 3. 策略market_data_list = [] # 存储历史数据# 下面订阅数据时会指定on_data为回调函数，接到数据就会执行on_datadef on_data(a, b, c, data): # 数据准备 bar = json.loads(data) market_data_list.append(bar) # 日线date格式是2019-01-01 market_data_df = pd.DataFrame(market_data_list).set_index(&#x27;date&#x27;, drop=False) # 计算指标 ind = QA.QA_indicator_MA(market_data_df, 2, 4) # 计算MA2和MA4 print(ind) # 策略逻辑 MA2 = ind.iloc[-1][&#x27;MA2&#x27;] # 取最新的MA2 MA4 = ind.iloc[-1][&#x27;MA4&#x27;] # 取最新的MA4 code = bar[&#x27;code&#x27;] # 合约代码 trade_price = bar[&#x27;close&#x27;] # 最新收盘价 trade_amount = 1 # 1手 trade_time = bar[&#x27;date&#x27;] + &#x27; 00:00:00&#x27; # 由于日线date的格式是2019-01-01，所以要加后面的时间，否则无法计算指标，后面的问题章节有详细说明。 code_hold_available = acc.hold_available.get(code, 0) # 合约目前的持仓情况 if MA2 &gt; MA4: if code_hold_available == 0: print(&#x27;买多&#x27;) sendorder(code, trade_price, trade_amount, QA.ORDER_DIRECTION.BUY_OPEN, trade_time) elif code_hold_available &gt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平空&#x27;) sendorder(code, trade_price, trade_amount, QA.ORDER_DIRECTION.BUY_CLOSE, trade_time) elif MA4 &gt; MA2: if code_hold_available == 0: print(&#x27;卖空&#x27;) sendorder(code, trade_price, trade_amount, QA.ORDER_DIRECTION.SELL_OPEN, trade_time) elif code_hold_available &lt; 0: print(&#x27;持有&#x27;) else: print(&#x27;平多&#x27;) sendorder(code, trade_price, trade_amount, QA.ORDER_DIRECTION.SELL_CLOSE, trade_time) else: print(&#x27;不操作&#x27;)# 4. 订阅数据sub = subscriber(exchange=&#x27;x1&#x27;) # Exchange名为x1，在15672页面能看到sub.callback=on_data # 指定回调函数threading.Thread(target=sub.start).start() # 开线程执行订阅，防止线程阻塞，后面的发布代码无法执行# 5. 数据获取并推送数据# 获取df = QA.QA_fetch_get_future_day(&#x27;tdx&#x27;, &#x27;RBL8&#x27;, &#x27;2019-08-01&#x27;, &#x27;2019-08-30&#x27;)# 推送pub = publisher(exchange=&#x27;x1&#x27;) # 跟订阅的Exchange一致for idx, item in df.iterrows(): pub.pub(item.to_json()) # 每行数据换成json，pub出去，上面的on_data就会收到，开始执行策略。# 6. 查看结果risk = QA.QA_Risk(acc)performance = QA.QA_Performance(acc)acc.history_table # 交易记录risk.plot_assets_curve() # 资产曲线performance.pnl # 盈利情况# 7. 保存结果risk.save()acc.save() 问题 需要先存数据，因为qa_risk会调用QA_fetch_stock_day_adv，这个方法会从数据库读数据，读不到数据后面的指标不能计算（已解决） receive_simpledeal的trade_time，要用%Y-%m-%d %H:%M:%S格式，因为history_min会用到这个格式，格式不对会计算不出history_min，导致后面指标不能计算。（已解决） 在存了数据，trade_time写对之后，performance.pnl等等都能计算出来了，但是81界面的绩效分析就是出不来，不知道为什么（未解决） acc = port.new_account(‘test1’, 100000, QA.MARKET_TYPE.FUTURE_CN, auto_reload=False)，跑第一次的时候会把acc存在数据库，第二次再跑的时候，创建的acc，market_type会变成stock_cn，因为走的else代码块，创建走的if，具体看QAPortfolio的第385行。但是如果auto_reload是true的话就不会有问题，因为会从数据库读取覆盖掉创建时赋值的参数，缺点是交易数据的累计的，跑不同的数据，交易记录会混在一起。（未解决）","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/tags/QUANTAXIS/"}]},{"title":"QUANTAXIS-QATrader模拟和实盘交易组件","slug":"knowledge/投资/量化投资/编程/框架/QUANTAXIS/QUANTAXIS-QATrader模拟和实盘交易组件","date":"2021-11-13T17:52:01.000Z","updated":"2021-11-13T17:54:53.000Z","comments":true,"path":"knowledge/065307546a65df5c/","link":"","permalink":"https://xiaofan.art/knowledge/065307546a65df5c/","excerpt":"模拟盘启动模拟账户123456# 进入qatrader容器docker exec -it qatrader /bin/bash# 开启模拟盘账户# 当指定一个新的acc执行这个命令时，会创建一个acc，存在数据库中# 已经创建过的acc可以在81页面查看，但是必须开启qatrader才能交易qatrader --acc 101010 --pwd 101010 --broker QUANTAXIS","text":"模拟盘启动模拟账户123456# 进入qatrader容器docker exec -it qatrader /bin/bash# 开启模拟盘账户# 当指定一个新的acc执行这个命令时，会创建一个acc，存在数据库中# 已经创建过的acc可以在81页面查看，但是必须开启qatrader才能交易qatrader --acc 101010 --pwd 101010 --broker QUANTAXIS 输出下图日志就说明启动成功 同时RabbitMQ中会增加3个Exchange Exchange QAORDER_ROUTER增加账户信息 启动问题qatrader报参数个数错误，原因是python版本错误，应该用python3.6或3.7 qatrader报socket is already closed，原因是因为电脑刚刚从睡眠状态唤醒，需要等一会儿或者重启 在81页面中查看模拟账户 向模拟账户下单首先下单前要明确一个概念，模拟盘下单就像是在同花顺的模拟账户中操作，所以下单数据都是跟实盘一样的，除了资金是虚拟。 12345678910111213141516171819from QAPUBSUB.producer import publisher_routingimport datetime# 向模拟盘下单使用的是publisher_routing，而不是publisherpub = publisher_routing(exchange=&#x27;QAORDER_ROUTER&#x27;)# 卖空pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: &#x27;101010&#x27;, # 账户名 &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: &#x27;rb2201&#x27;, &#x27;price&#x27;: 3816, &#x27;order_direction&#x27;: &#x27;SELL&#x27;, &#x27;order_offset&#x27;: &#x27;OPEN&#x27;, &#x27;volume&#x27;: 1, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;,&#125;), routing_key=&#x27;101010&#x27;) # 账户名 发单后就可以在模拟账户中查看 下单问题 合约不合法，表示code参数有问题，code参数不能是指数或连续或过期合约，例如螺纹指数合约RBL8，2020年1月的螺纹合约RB2001 查看持仓和委托等信息123456789101112import pymongoimport os# 连接数据库db = pymongo.MongoClient(os.getenv(&#x27;MONGODB&#x27;)).QAREALTIME# 查到账户simacc = db.account.find_one(&#123;&#x27;account_cookie&#x27;: &#x27;101010&#x27;&#125;)# 获取委托信息simacc[&#x27;orders&#x27;]# 获取成交信息simacc[&#x27;trades&#x27;]# 获取持仓simacc[&#x27;positions&#x27;] 取消委托12345pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;cancel_order&#x27;, &#x27;account_cookie&#x27;: &#x27;101010&#x27;, # 账户名 &#x27;order_id&#x27;: &#x27;QAOTG_jHEJZXWk&#x27;,&#125;), routing_key=&#x27;101010&#x27;) # 账户名 问题，event显示撤单成功，但是orders里面还是显示ALIVE，难道是因为在非交易时间发起的撤单？ 多账户下单 同一个signal，只需要修改account就可以实现多账户下单，并且可以同时向模拟盘和实盘下单 12345678910111213for acc in [&#x27;101010&#x27;, &#x27;202020&#x27;]: pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: acc, # 账户名 &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: &#x27;rb2201&#x27;, &#x27;price&#x27;: 3816, &#x27;order_direction&#x27;: &#x27;SELL&#x27;, &#x27;order_offset&#x27;: &#x27;OPEN&#x27;, &#x27;volume&#x27;: 1, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;, &#125;), routing_key=acc) # 账户名 Http请求下单 Http下单跟Python下单一样，实际都是向名为QAORDER_ROUTER的Exchange发送信息。 首先开启qatraderserver，提供Http服务 12# docker版本的qatrader默认会启动qatraderserver，所以可以不用再手动启动，配置启动qatraderserver的位置在docker-compose.yaml中qatraderserver # 再次启动，报端口占用 接口查看https://github.com/yutiansut/QATrader 实盘下单操作汇总卖空123456789101112pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: &#x27;101010&#x27;, # 账户名 &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: &#x27;rb2201&#x27;, &#x27;price&#x27;: 3816, &#x27;order_direction&#x27;: &#x27;SELL&#x27;, &#x27;order_offset&#x27;: &#x27;OPEN&#x27;, &#x27;volume&#x27;: 1, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;,&#125;), routing_key=&#x27;101010&#x27;) # 账户名 平今多123456789101112pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;sendorder&#x27;, &#x27;account_cookie&#x27;: &#x27;101010&#x27;, # 账户名 &#x27;strategy_id&#x27;: &#x27;test&#x27;, &#x27;code&#x27;: &#x27;rb2201&#x27;, &#x27;price&#x27;: 3816, &#x27;order_direction&#x27;: &#x27;SELL&#x27;, &#x27;order_offset&#x27;: &#x27;CLOSETODAY&#x27;, &#x27;volume&#x27;: 1, &#x27;order_time&#x27;: str(datetime.datetime.now()), &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;,&#125;), routing_key=&#x27;101010&#x27;) # 账户名 取消委托12345pub.pub(json.dumps(&#123; &#x27;topic&#x27;: &#x27;cancel_order&#x27;, &#x27;account_cookie&#x27;: &#x27;101010&#x27;, # 账户名 &#x27;order_id&#x27;: &#x27;QAOTG_jHEJZXWk&#x27;,&#125;), routing_key=&#x27;101010&#x27;) # 账户名 实盘账户数据库说明https://doc.shinnytech.com/tqsdk2/latest/reference/tqsdk2.objs.position.html 持仓说明simacc[‘positions’][‘SHFE_rb2201’] 123456789101112131415161718192021222324252627282930313233343536373839&#123;&#x27;user_id&#x27;: &#x27;marco07281&#x27;, # qatrader命令的--acc指定的用户名 &#x27;exchange_id&#x27;: &#x27;SHFE&#x27;, # 交易所id &#x27;instrument_id&#x27;: &#x27;rb2201&#x27;, # 合约名称 &#x27;volume_long_today&#x27;: 1, # 今日下单的多单 &#x27;volume_long_his&#x27;: 0, # 历史持有的多单 &#x27;volume_long&#x27;: 1, # 总多单 = 今日 + 历史 &#x27;volume_long_frozen_today&#x27;: 0, &#x27;volume_long_frozen_his&#x27;: 0, &#x27;volume_long_frozen&#x27;: 0, &#x27;volume_short_today&#x27;: 0, &#x27;volume_short_his&#x27;: 0, &#x27;volume_short&#x27;: 0, &#x27;volume_short_frozen_today&#x27;: 0, &#x27;volume_short_frozen_his&#x27;: 0, &#x27;volume_short_frozen&#x27;: 0, &#x27;volume_long_yd&#x27;: 0, &#x27;volume_short_yd&#x27;: 0, &#x27;pos_long_his&#x27;: 0, &#x27;pos_long_today&#x27;: 1, # 跟volume_long_today一样？ &#x27;pos_short_his&#x27;: 0, &#x27;pos_short_today&#x27;: 0, &#x27;open_price_long&#x27;: 4249.0, # 多仓均价？ &#x27;open_price_short&#x27;: 0.0, &#x27;open_cost_long&#x27;: 42490.0, # 持有的多单总成本？ &#x27;open_cost_short&#x27;: 0.0, &#x27;position_price_long&#x27;: 4249.0, # 跟open_price_long有什么区别？ &#x27;position_price_short&#x27;: 0.0, &#x27;position_cost_long&#x27;: 42490.0, # 跟open_cost_long有什么区别？ &#x27;position_cost_short&#x27;: 0.0, &#x27;last_price&#x27;: 4262.0, # 实时的价格，会跟着行情一直变 &#x27;float_profit_long&#x27;: 130.0, # 实时的多单浮盈？ &#x27;float_profit_short&#x27;: 0.0, # 实时的空单浮盈？ &#x27;float_profit&#x27;: 130.0, # 实时浮盈 &#x27;position_profit_long&#x27;: 130.0, # 跟float_profit_long有什么区别 &#x27;position_profit_short&#x27;: 0.0, &#x27;position_profit&#x27;: 130.0, # 跟float_profit有什么区别 &#x27;margin_long&#x27;: 3308.8, # 多单保证金 &#x27;margin_short&#x27;: 0.0, # 空单保证金 &#x27;margin&#x27;: 3308.8&#125; # 总保证金","categories":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/categories/QUANTAXIS/"}],"tags":[{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/tags/QUANTAXIS/"}]}],"categories":[{"name":"Plotly","slug":"Plotly","permalink":"https://xiaofan.art/categories/Plotly/"},{"name":"Python","slug":"Python","permalink":"https://xiaofan.art/categories/Python/"},{"name":"Windows","slug":"Windows","permalink":"https://xiaofan.art/categories/Windows/"},{"name":"VNPY","slug":"VNPY","permalink":"https://xiaofan.art/categories/VNPY/"},{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/categories/QUANTAXIS/"},{"name":"Docker","slug":"Docker","permalink":"https://xiaofan.art/categories/Docker/"}],"tags":[{"name":"Plotly","slug":"Plotly","permalink":"https://xiaofan.art/tags/Plotly/"},{"name":"Python","slug":"Python","permalink":"https://xiaofan.art/tags/Python/"},{"name":"Windows","slug":"Windows","permalink":"https://xiaofan.art/tags/Windows/"},{"name":"VNPY","slug":"VNPY","permalink":"https://xiaofan.art/tags/VNPY/"},{"name":"QUANTAXIS","slug":"QUANTAXIS","permalink":"https://xiaofan.art/tags/QUANTAXIS/"},{"name":"Docker","slug":"Docker","permalink":"https://xiaofan.art/tags/Docker/"}]}